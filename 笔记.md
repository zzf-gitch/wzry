**1.动画animation的属性**

```css
语法：animation: name 秒数(时间) linear(匀速播放)

基本使用属性：alternate：动画先正常运行再反方向运行，并持续交替运行;

animation-iteration-count: infinite | number;

infinite：无限循环

number: 循环的次数

linear：线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) (匀速播放)

ease：平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)

ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)

ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)

ease-in-out：由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)

step-start：等同于 steps(1, start)

step-end：等同于 steps(1, end)
```

**2.flex布局**

```css
1、flex-direction

2、flex-wrap

3、flex-flow

4、justify-content

5、align-items

6、align-content
```

```css
flex-direction: row | row-reverse | column | column-reverse;
它可能有4个值。

row（默认值）：主轴为水平方向，起点在左端。

row-reverse：主轴为水平方向，起点在右端。

column：主轴为垂直方向，起点在上沿。

column-reverse：主轴为垂直方向，起点在下沿。

flex-wrap: nowrap | wrap | wrap-reverse;

（1）nowrap（默认）：不换行。

（2）wrap：换行，第一行在上方。

（3）wrap-reverse：换行，第一行在下方
```

一.3 **flex-flow**属性

```css
flex-flow属性是**flex-direction属性和flex-wrap属性的简写**形式，默认值为row nowrap。
```

一.4 **justify-content**属性

```css
justify-content属性定义了项目在**主轴上的对齐方式**。

justify-content: flex-start | flex-end | center | space-between | space-around;

它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。

flex-start（默认值）：左对齐

flex-end：右对齐

center： 居中

space-between：两端对齐，项目之间的间隔都相等。

space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
```

一.5 align-items属性

```css
align-items属性定义项目在交叉轴上如何对齐。

align-items: flex-start | flex-end | center | baseline | stretch
它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。

flex-start：交叉轴的起点对齐。

flex-end：交叉轴的终点对齐。

center：交叉轴的中点对齐。

baseline: 项目的第一行文字的基线对齐。

stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
```

一.6 align-content属性

```css
align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

align-content: stretch | flex-start | flex-end | center | space-between | space-around;
该属性可能取6个值。

stretch（默认值）：轴线占满整个交叉轴。

flex-start：与交叉轴的起点对齐。

flex-end：与交叉轴的终点对齐。

center：与交叉轴的中点对齐。

space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。

space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。


```

**3.element-plus里面的input框去除边框和foucs**

**1.1去除input输入框的边框**

```JavaScript
	     	.demo-ruleForm（input最大的父级） >>> input {			
						outline: none;
						box-shadow: none;
					}
```

**1.2修改input输入框样式**

```JavaScript
			.demo-ruleForm >>> input {
						height: 50px !important;
						opacity: 0.5;
						border-radius: 30px !important;
						background-color: #f2f3f5;
                         }
```

**1.3修改鼠标点击input输入框获取焦点时候的样式**

```JavaScript
			.el-input /deep/ .el-input__inner:focus {
						color: #2186e4;
						}
```

**1.4修改placeholder的样式**

```JavaScript
			.el-input /deep/ .el-input__inner::placeholder {
						text-align: center !important;
						color: #ced1d8 !important;
						}
```

```javascript
***//控制开启全屏和关闭全屏***
const fullScreen = ref(false);
***//浏览器是否支持全屏模式***

const isSupport = document.fullscreenEnabled;

const screen = () => {

***//浏览器是否支持全屏模式***

 if (isSupport) {

  ***//判断Document.fullscreenElement只读属性返回Element当前在本文档中以全屏模式呈现的，或者 如果 null当前未使用全屏模式***

  if (document.fullscreenElement) {

   ***//Document.exitFullscreen() 方法用于让当前文档退出全屏模式（原文表述不准确，详见备注）。调用这个方法会让文档回退到上一个调用Element.requestFullscreen()方法进入全屏模式之前的状态***

   document.exitFullscreen();

   fullScreen.value = false;

   ElMessage({

   showClose: true,

   message: "退出全屏",

   type: "error",

  });

  } else {

   ***// 这里选择将html元素全屏展示，也可以选择其它元素***

   ***//Element.requestFullscreen() 方法用于发出异步请求使元素进入全屏模式***

   ***//Document.documentElement返回 的 Element根元素document（例如，<html>HTML 文档的元素）***

   document.documentElement.requestFullscreen();

   ElMessage({

   showClose: true,

   message: "进入全屏",

   type: "success",

  });

   fullScreen.value = true;

  }

 }
```

**echarts图表根据点击box全屏变大关闭全屏缩小**

```javascript
<template>
  <div class="brsy">
    <div class="box" id="main_left">
      <div id="main" @click="open"></div>
      <i class="iconfont icon-close" @click="close"></i>
    </div>
  </div>
</template>
<script setup>
import * as echarts from "echarts";
import { ref, reactive, onMounted } from "vue";
const isSupport=document.fullscreenEnabled
const open = () => {
    if(isSupport){
        let dom=document.getElementById("main_left")
        if(dom.requestFullscreen){
            dom.requestFullscreen()
        }else if(dom.webkitRequestFullScreen){
            dom.webkitRequestFullScreen()
        }else if(dom.mozRequestFullScreen){
            dom.mozRequestFullScreen()
        }else if(dom.msRequestFullscreen){
            dom.msRequestFullscreen()
        }
    }
}
const close=()=>{
    document.exitFullscreen()
}
const getlist = () => {
  var chartDom = document.getElementById("main");
  var myChart = echarts.init(chartDom);
  var option;
  window.addEventListener("click",()=>{
      myChart.resize();
  })
  // prettier-ignore
  let dataAxis = ['以', '雷', '霆', '击', '碎', '黑', '暗'];
  // prettier-ignore
  let data = [220, 182, 191, 234, 290, 330, 310, 123, 442];
  let yMax = 500;
  let dataShadow = [];
  for (let i = 0; i < data.length; i++) {
    dataShadow.push(yMax);
  }
  option = {
    title: {
      text: "特性示例：渐变色 阴影 点击缩放",
      subtext: "Feature Sample: Gradient Color, Shadow, Click Zoom",
    },
    xAxis: {
      data: dataAxis,
      axisLabel: {
        inside: true,
        color: "#fff",
      },
      axisTick: {
        show: false,
      },
      axisLine: {
        show: false,
      },
      z: 10,
    },
    yAxis: {
      axisLine: {
        show: false,
      },
      axisTick: {
        show: false,
      },
      axisLabel: {
        color: "#999",
      },
    },
    dataZoom: [
      {
        type: "inside",
      },
    ],
    series: [
      {
        type: "bar",
        showBackground: true,
        itemStyle: {
          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            { offset: 0, color: "#83bff6" },
            { offset: 0.5, color: "#188df0" },
            { offset: 1, color: "#188df0" },
          ]),
        },
        emphasis: {
          itemStyle: {
            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
              { offset: 0, color: "#2378f7" },
              { offset: 0.7, color: "#2378f7" },
              { offset: 1, color: "#83bff6" },
            ]),
          },
        },
        data: data,
      },
    ],
  };
  // Enable data zoom when user click bar.
  const zoomSize = 6;
  myChart.on("click", function (params) {
    console.log(dataAxis[Math.max(params.dataIndex - zoomSize / 2, 0)]);
    myChart.dispatchAction({
      type: "dataZoom",
      startValue: dataAxis[Math.max(params.dataIndex - zoomSize / 2, 0)],
      endValue:
        dataAxis[Math.min(params.dataIndex + zoomSize / 2, data.length - 1)],
    });
  });
      myChart.setOption(option);
};
onMounted(() => {
  getlist();
});
</script>
```



```javascript
<style scoped>
.brsy {
  width: 100%;
  height: 100%;
  display: flex;
  padding: 50px;
}
.box {
  width: 300px;
  height: 300px;
  border: 1px solid #e6a349;
  background-color: #fa9899;
  transition: all 0.5s;
  position: relative;
}
.box:hover {
  transform: translateY(-10px);
  box-shadow: 0 10px 30px 5px rgba(0, 0, 0, 0.75);
}
#main{
    width: 100%;
    height: 100%;
}
.icon-close{
    position: absolute;
    background-color:white;
    border-radius: 50%;
    color: black;
    top: 10px;
    right: 10px;
}
</style>
```



**disabled**

1. ```javascript
   1. disabled是一个表单元素所以div标签以及其他不属于表单标签使用都没有效果
   
   2. 只有表单元素和button按钮使用有效
   
   3. 双向绑定:disabled="disabled"  const disabled=ref(true)
   
   4. 禁用的时候的css样式  类名:disabled{background-color:gray;}
   ```

   

**检测数据类型方法：**

**1.typeof**

​        

```javascript
检测数据类型
```

**2.instanceof**

​       

```javascript
 检测当前实例是否属于某一个类,属于的话返回true,不属于返回false
```



**v-for动态修改class样式通过index下标**

**1.template部分**

```javascript
<div v-for="(item, index) in state.etCourseChapters" :key="index">
            <div :class="index == currentIndex ? 'listtwo' : 'listone'" @click="video(item,index,$event)">
              <div style="width: 85%;overflow: hidden;text-overflow: ellipsis;white-space: nowrap;">
                {{ item.coursewareName }}</div>
              <p style="margin-left: auto">100%</p>
            </div>
</div>
```

**2.script部分**

```JavaScript
const currentIndex = ref()
const video = async (item,index,e) => {
  console.log(e);
  console.log(e.target.scrollWidth);
  console.log(e.target.clientWidth);
  currentIndex.value=index;
}
```

**3.css部分**

```JavaScript
.listone {
          width: 100%;
          display: flex;
          font-size: 16px;
          padding-top: 20px;
          color: #818181 !important;
          }
          
.listtwo {
          width: 100%;
          display: flex;
          font-size: 16px;
          padding-top: 20px;
          color: skyblue;
}
```

**js中splice和slice方法的用法和区别**

**1.splice**

splice方法向[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)中添加项目或删除项目，并返回删除的项目

**语法**

array.splice(index, howmany, item1,...itemx)

1. ```javascript
   1. index 必须。整数，指定在什么位置添加/删除项目，使用负值指定从数组末尾开始的位置。
   
   2. 可选，要删除的项目数。若设置为0，则不会删除任何项目。
   
   3. item1,...,itemx 可选，要添加到数组中的新项目。
   
   返回值： 新数组，包含删除的项目 （如果有）。
   ```

   


**实例**

```javascript
let fruits = ["Banana", "Orange", "Apple", "Mango"];
let ret = fruits.splice(2, 1, "Lemon", "Kiwi");
console.log(fruits) 
 结果： ["Banana", "Orange", "Apple", "Mango"]
console.log(ret) 
结果： ["Apple"]
```

**2. slice**

```javascript
从已有的数组中返回选定的元素

提取数组中的某一部分，并以新的字符串返回被提取的部分

*slice方法不会改变原始数组*
```

**语法**

array.slice(start, end)

```javascript
1. start 可选，规定从何处开始选取。如果该参数为负数，则表示从原数组中倒数第几个元素开始提取。
2. end 可选，规定从何处结束选取。该参数是数组片段结束处的数组下标，截取的片段不包含改元素。
3. 返回值： 返回一个新的数组，包含从start(包括该元素) 到end（不包括该元素）的arrayObject中的元素。
```



**实例**

```javascript
var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];

 var citrus = fruits.slice(1,3); 

console.log(citrus) // [Orange,Lemon]
```

**3. 区别**

1. ```javascript
   1. splice 直接操作原数组，会改变原数组，slice不会改变原数组
   2. splice 返回增加或删除的值，slice返回截取的数组片段
   3. splice 可以用于往数组中插入新的值, slice只能用于获取部分数组片段。
   4. slice也可用于字符串的截取
   5. 总结
   6. 如果想截取原数组的某些数组片段，用slice，取返回值
   7. 想增加或删除原数组中的某些值，用splice
   8. 字符串的截取，用slice
   ```

   

**js截取split*****js截取\*字符串的某段值，\*split\*方法**

```JavaScript
var load="青岛-南京";
var startcity='';
var endcity='';
startcity=load.split("-")[0];     //输出青岛
endcity=load.split("-")[1];       //输出南京
```

1、split("-")为指定分隔符，

2、[0]为分割后，取“-”前面的值

3、[1]为分割后，取“-”后面的值



**Gird布局**

Grid 是二维网格系统。它可以用来构建复杂的布局以及较小的界面。

**属性：grid-template-columns**

定义列，按照你希望它们在网格中出现的顺序，把**grid -template-columns** 属性设置为列大小

```JavaScript
.grid {
    display: grid;
    grid-template-columns: 100px 100px 100px; // 定义三个宽度为100px的单元格
}
```

**属性：grid-template-rows**

grid-template-rows 用于定义网格中行的数量和大小。

```JavaScript
.grid {
    display: grid;
    grid-template-columns: 100px 100px 100px;
    grid-template-rows: 100px 100px 100px; // 高度 与‘columns’类似
}
```

**属性：grid-template**

grid 是 grid-template-rows、grid-template-columns 和 grid-template-areas 三个属性的简写。

```JavaScript
.grid {
    display: grid;
    grid-template:
        "header header  header" 80px
        "nav    article article" 600px
        / 100px 1fr;
}
```

**属性：fr**

*fr* 是为 css 网格布局创建的新单位。 *fr* 使你不需要计算百分比就能创建灵活的网格， 1fr 表示可用空间的一等份。

```JavaScript
.grid {
    display: grid;
    grid-template-columns: 3fr 4fr 3fr; // 宽度分为3+4+3=10个等份，4个单元格分别占3、4、3份
    grid-template-columns: 3fr 4fr 3fr 2fr; // 宽度分为3+4+3+2=12个等份，4个单元格分别占3、4、3、2份
}
```

**属性：grid-auto-flow**

grid-auto-flow 属性控制 网格单元 如何流入网格，其默认值为 row。网格中的“网格单元”将会被一一填充，直到没有剩余的项目为止。

```JavaScript
.grid {
    display: grid;
    grid-template-columns: 100px 100px 100px;
    grid-auto-flow: column;
}
```

**函数：repeat()**

repeat() 函数有助于使 网格轨道 列表变得不是那么多余，并为其添加了语义层。

```JavaScript
.grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr 2fr); // 重复3次的 1fr 2fr。 还可以是：grid-template-columns:2fr repeat(5，1fr) 4fr;
}
```

**cursor**

光标 属性可以指定当滑鼠标指向哪个物件时，显示不同的光标.

```JavaScript
cursor: pointer; //鼠标变小手
cursor: default; //平台相关的默认光标。通常是箭头。
cursor: none; //不渲染光标。
cursor: context-menu; //上下文菜单可用。
cursor: help; //提供帮助信息。
cursor: progress; //程序在后台忙碌，但用户仍然可以与界面交互（与 相比wait）。
cursor: wait; //程序很忙，用户无法与界面交互（对比progress）。有时是沙漏或手表的图像。
cursor: not-allowed; //请求的操作将不会执行。
cursor: zoom-in; //可以放大某些东西。
cursor: zoom-out; ////可以缩小某些东西。
cursor: grab; //可以抓取某些东西（拖动以移动）。
cursor: text; //可以选择文本。通常是工字梁的形状。
cursor: copy; //有些东西要被复制。
cursor: move; //有些东西要被移动。
cursor: no-drop; //物品可能不会被丢弃在当前位置。 错误 275173：在Windows 和 Mac OS Xno-drop上，与not-allowed.

```

**pointer-events**

属性指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 [target](https://developer.mozilla.org/en-US/docs/Web/API/Event/target)

```JavaScript
auto
```

与`pointer-events`属性未指定时的表现效果相同，对于 SVG 内容，该值与`visiblePainted`效果相同

```JavaScript
none
```

```JavaScript
<ul>
<li><a href="https://developer.mozilla.org/">MDN</a></li>
<li><a href="http://example.com">example.com</a></li>
</ul>
```

Copy to Clipboard

```JavaScript
a[href="http://example.com"] {
  pointer-events: none;
}
```

元素永远不会成为鼠标事件的[target](https://developer.mozilla.org/en-US/docs/Web/API/event.target)。但是，当其后代元素的`pointer-events`属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。

```JavaScript
visiblePainted
```

只适用于 SVG。元素只有在以下情况才会成为鼠标事件的目标：

- `visibility`属性值为`visible`，且鼠标指针在元素内部，且`fill`属性指定了`none`之外的值
- `visibility`属性值为`visible`，鼠标指针在元素边界上，且`stroke`属性指定了`none`之外的值

```JavaScript
visibleFill
```

只适用于 SVG。只有在元素`visibility`属性值为`visible`，且鼠标指针在元素内部时，元素才会成为鼠标事件的目标，`fill`属性的值不影响事件处理。

```JavaScript
visibleStroke
```

只适用于 SVG。只有在元素`visibility`属性值为`visible`，且鼠标指针在元素边界时，元素才会成为鼠标事件的目标，`stroke`属性的值不影响事件处理。

```JavaScript
visible
```

只适用于 SVG。只有在元素`visibility`属性值为`visible`，且鼠标指针在元素内部或边界时，元素才会成为鼠标事件的目标，`fill`和`stroke`属性的值不影响事件处理。

```JavaScript
painted
```

只适用于 SVG。元素只有在以下情况才会成为鼠标事件的目标：

- 鼠标指针在元素内部，且`fill`属性指定了`none`之外的值
- 鼠标指针在元素边界上，且`stroke`属性指定了`none`之外的值

`visibility`属性的值不影响事件处理。

```JavaScript
fill
```

只适用于 SVG。只有鼠标指针在元素内部时，元素才会成为鼠标事件的目标，`fill`和`visibility`属性的值不影响事件处理。

```JavaScript
stroke
```

只适用于 SVG。只有鼠标指针在元素边界上时，元素才会成为鼠标事件的目标，`stroke`和`visibility`属性的值不影响事件处理。

```JavaScript
all
```

只适用于 SVG。只有鼠标指针在元素内部或边界时，元素才会成为鼠标事件的目标，`fill`、`stroke`和`visibility`属性的值不影响事件处理。



**CSS文本属性（常用）**

1.文本颜色

 color属性可以定义文本颜色

```JavaScript
	 p {
            color: red;
        }
```

| **表示** | **属性值**                            |
| -------- | ------------------------------------- |
| 颜色值   | red，green，red等                     |
| 十六进制 | \#FF00000,#FF66000等                  |
| RGB代码  | rgb（255,0,0）或者rgb（100%，0%，0%） |

2. 对齐文本

text-align 属性用于设置元素内文本内容的水平对齐方式

```javascript
	 h2 {
            text-align: center;
        }
```

| **属性值** | ** 说明** |
| ---------- | --------- |
| left       | 左对齐    |
| right      | 右对齐    |
| center     | 居中对齐  |

3. 装饰本文

text-decoration 属性给文本修饰。如下划线、删除线、上划线

```javascript
	div {
            text-decoration: underline;
        }
```



| **属性值**   | ** 描述**                         |
| ------------ | --------------------------------- |
| none         | 默认没有装饰线（最常用）          |
| underline    | 下划线。链接a默认带下划线（常用） |
| overline     | 上划线（几乎不用）                |
| line-through | 删除线（不常用）                  |

4. 文本缩进

text-indent属性来指定文本第一行缩进，通常用于段落缩进。

```javascript
	  p {
            text-indent: 2em;
        }
```

注：em是当前一个元素的大小，如当前元素无设置大小，会以父级元素显示

5. 行间距

line-height 属性设置行间距的距离（行高）可以控制文字行与行之间的距离

```javascript
 	  p {
            line-height: 20px;
        }
```

```javascript
/* h-shadow 水平阴影的位置。允许负值。 | v-shadow 必需。垂直阴影的位置。允许负值。 | blur可选。模糊距离。 | spread可选。阴影的尺寸。 | color可选。阴影的颜色。请参阅 CSS 颜色值。|inset可选。将外部阴影 (outset) 改为内部阴影。 */
box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);
//必需。水平阴影的位置。允许负值。  	必需。垂直阴影的位置。允许负值。 可选。模糊的距离。 可选。阴影的颜色。参阅 CSS 颜色值。
text-shadow: 5px 5px 5px #FF0000;
```

**vue页面渲染word文件**
**安装 npm 依赖**
**npm i docx-preview@0.1.4**
**npm i jszip**
**vue2获取本地word文件:**
**html:**

```html
<template>
  <div class="my-component" ref="preview">
    <input type="file" @change="preview" ref="file">
  </div>
</template>
```

**script:**

```javascript
<script>
const docx = require('docx-preview');
window.JSZip = require('jszip')
export default {
  methods:{
    preview(e){
      docx.renderAsync(this.$refs.file.files[0],this.$refs.preview) // 渲染到页面预览
    }
  }
};
</script>
```

**css:**

```css
.my-component{
  width: 100%;
  height: 90vh;
  border: 1px solid #000;
}
```

**vue2获取word后台返回的地址渲染到页面:**

**html:**

```html
<el-button type="primary" @click="download">点击</el-button>
<div ref="file" class="file"></div>
```

**script:**

```javascript
<script>
import axios from 'axios'
const docx = require('docx-preview');
window.JSZip = require('jszip')
export default {
  methods:{
    download() {
      // word
      axios.request({
        method: "GET",
        url: 'http://192.168.11.16:7703/safe-file-					b2/files/B2/docx/1659518167775/GIS%E5%B9%B3%E5%8F%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E9%87%87%E8%B4%AD%E5%8F%8A%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%20%E6%8B%9B%E6%A0%87%E6%96%87%E4%BB%B6(1).docx', //路径
        responseType: "blob", //告诉服务器想到的响应格式
      })
        .then((res) => {
          console.log(res);
          docx.renderAsync(res.data, this.$refs.file);
        })
    }
  }
};
</script>
```

**css:**

```css
.file{
  width: 100%;
  height: 500px;
  overflow:hidden;
  overflow-y:scroll;
}
```

**vue3获取本地word文件:**
**html:**

```html
	<div class="my-component" ref="previews">1``
          <input type="file" @change="preview" ref="file">
    </div>
```

**script:**

```javascript
const docx = require('docx-preview');
window.JSZip = require('jszip')
const previews = ref(null)
const file = ref(null)
const preview = (e) => {
    console.log(file.value.files[0]);
    console.dir(previews.value);
    docx.renderAsync(file.value.files[0], previews.value) // 渲染到页面预览
}
```

**css:**

```css
.my-component {
          width: 100%;
          height: 90vh;
          border: 1px solid #000;
     }
```

**vue3获取word后台返回的地址渲染的到页面:**

**html:**

```html
<div class="word">
       <el-button type="primary" @click="download">点击下载</el-button>
       <div ref="file" class="file"></div>
</div>
```

**script:**

```javascript
import axios from 'axios'
const docx= require('docx-preview')
window.JSZip = require('jszip')
const file=ref(null)
const download=()=>{
    axios.request({
            method: "GET",
            url: 'http://192.168.11.16:7703/safe-file-b2/files/B2/docx/1659518167775/GIS%E5%B9%B3%E5%8F%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E9%87%87%E8%B4%AD%E5%8F%8A%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%20%E6%8B%9B%E6%A0%87%E6%96%87%E4%BB%B6(1).docx', //路径
            responseType: "blob", //告诉服务器想到的响应格式
          })
          .then((res) => {
            console.log(res);
              docx.renderAsync(res.data, file.value);
          })
}
```

**css:**

```scss
.word{
        width: 50%;
        height: 500px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        flex-direction: column;
        margin-top: 50px;
        .file{
            width: 100%;
            height: 100%;
            overflow: hidden;
            overflow-y: scroll;
        }
    }
```

**web前端技术学习网:https://kuangyx.cn/docs/%E6%96%87%E7%AB%A0/%E5%89%8D%E7%AB%AF/vue%E9%A2%84%E8%A7%88word%E6%96%87%E4%BB%B6docx.html#%E9%A2%84%E8%A7%88%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6**

**本地项目上传到gitee步骤，及如何更新拉取等操作**

**传到gitee步骤**

**第一步：进入要上传的项目，右键点击 Git Bash Here。**
**第二步：初始化。 git init**

**第三步：登陆到gitee中，新建仓库，并复制仓库地址。**

**第四步：在命令行输入 git remote add origin +复制的地址**

**第五步：输入git pull origin master。这时会弹出输入账号密码框。填写后继续下一步。**

**第六步：输入 git add .**

**最后： git push origin master**



**更新拉取步骤**
**1.克隆（将项目拉取到本地）**
git clone +项目地址

**2.修改后更新到gitee**
首先：git add 需要更新提交的文件路径
然后：git commit -m “测试修改后上传gitee” 备注提交的信息
最后: git push origin master 推送到gitee上

**3.从gitee拉取最近的代码**
git pull origin master

**4.删除gitee多余的文件夹**
git rm -r --cached 删除的文件名称
git commit -m ‘操作说明’
git push -u origin master

**5.查看项目有哪些文件**
dir

**文本强制不换行超出盒子的宽度隐藏剩余并且显示省略号**

html:

```html
<template #default="scope">
     <el-tooltip :content="scope.row.money" :disabled="disabled" effect="dark" placement="top">
        <div @mouseenter="mouseenter($event)" class="wz">{{ scope.row.money }}</div>
     </el-tooltip>
</template>
```

js:

```javascript
const disabled=ref(true)
const mouseenter=(event)=>{
  let e=event.target
  // 文本的实际宽度
  let e_weight=e.scrollWidth
  // 文本的可使宽度
  let e_content=e.clientWidth
  // 文本的实际宽度大于文本的可使宽,文字溢出
  if(e_weight>e_content){
    disabled.value=false
  }else{
    disabled.value=true
  }
}
```

css:

```css
.wz{
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```

**Vue中vuex的使用**

**vue3**

store/index.js 创建store对象并导出store

```javascript
import { createStore } from 'vuex'

export default createStore({
  state: {
  },
  mutations: {
  },
  actions: {
  },
  modules: {
  }
})
```

main.js 引入并使用

```javascript
import store from './store'
...
app.use(store)
```

#### Vue3中获取 store 实例对象的方法

vue3 中的 setup 在 beforecreate 和 created 前执行，此时 vue对象还未被创建，没有了之前的this，所以此处我们需要用到另一种方法来获取到 store 对象。

```javascript
import { useStore } from 'vuex' // 引入useStore 方法

const store = useStore()  // 该方法用于返回store 实例

console.log(store)  // store 实例对象
```

#### 1. `state`

存放数据的地方

```javascript
state: {
  count: 100,
  num: 10
},
```

使用：使用方法大致与vue2.x中的版本相同，通过 `$store.state.属性名` 来获取state中的属性。

```html
//template中

<span>{{$store.state.count}}</span>
<span>{{$store.state.num}}</span>

```

可以在 state 中直接进行数据变化的操作，但Vue不建议这么做。因为对于vue开发工具 devtools 来说，直接在state中进行数据改变，devtools是跟踪不到的。vuex中希望通过 action（进行异步操作）或是 mutations（同步操作）来进行数据改变的操作，这样在 devtools 中才能直接观察出数据的变化以及记录，方便开发者调试。

#### 2. `mutations`

vuex的store状态更新的唯一方式：提交 mutation

同步操作可以直接在mutatuions中直接进行

mutions 主要包含2部分:

1. **字符串的事件类型 (type)**

1. 一个**回调函数（handler）**该回调函数的第一个参数是 state

```javascript
mutations: {
  // 传入 state
  increment (state) {
    state.count++
  }
}
```

template 中通过 `$store.commit('方法名')` 触发

在 **vue3.x** 中需要拿到** store 实例**的话，需要调用** `useStore` **这样一个函数，在 vuex 中导入

```javascript
// 导入 useStore 函数
import { useStore } from 'vuex'
const store = useStore()
store.commit('increment')

```

**mution 的参数与传参方法**

mution 接收参数直接写在定义的方法里边即可接受传递的参数

```javascript
// ...state定义count
mutations: {
  sum (state, num) {
    state.count += num
  }
}
```

通过 [commit](https://so.csdn.net/so/search?q=commit&spm=1001.2101.3001.7020) 的进行参数传递

使用 `store.commit('mution中函数名', '需要传递的参数' )` 在commit里添加参数的方式进行传递

```javascript
<h2>{{this.$store.state.count}}</h2>
<button @click="add(10)">++</button>
...
<script setup>
// 获取store实例，获取方式看上边获取store实例方法
const add = (num) => {
  store.commit('sum', num)
}
</script>
```

**mution 的提交风格**

前面提到了 mution 主要包含 type 和 回调函数 两部分, 和通过commit payload的方式进行参数传递（提交）,下面我们可以

用这种方式进行 mution 的提交

```javascript
const add = (num) => {
  store.commit({
    type: 'sum',  // 类型就是mution中定义的方法名称
    num
  })
}

...
mutations: {
  sum (state, payload) {
    state.count += payload.num
  }
}

```

#### 3. `actions`

异步操作在action中进行，再传递到mutation

action基本使用如下：

action 中定义的方法默认参数为** `context` 上下文**， 可以理解为 store 对象

**通过 context 上下文对象，拿到store，通过 `commit` 触发 mution 中的方法**，以此来完成异步操作

```javascript
...
mutations: {
  sum (state, num) {
    state.count += num
  }
},
actions: {
  // context 上下文对象，可以理解为store
  sum_actions (context, num) {
    setTimeout(() => {
      context.commit('sum', num)  // 通过context去触发mutions中的sum
    }, 1000)
  }
},
```

**在template 中通过`dispatch` 调用action 中定义的sum_action 方法**

```javascript
// ...template
store.dispatch('sum_actions', num)
```

```javascript
// ...
const addAction = (num) => {
  store.dispatch('sum_actions', {
    num
  }).then((res) => {
    console.log(res)
  }).catch((err) => {
    console.log(err)
  })
}

```

sun_action方法返回一个promise，当累加的值大于30时不再累加，抛出错误。

```javascript
 actions: {
    sum_actions (context, payload) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          // 通过 context 上下文对象拿到 count
          if (context.state.count < 30) {
            context.commit('sum', payload.num)
            resolve('异步操作执行成功')
          } else {
            reject(new Error('异步操作执行错误'))
          }
        }, 1000)
      })
    }
  },

```

#### 4. `getters`

```javascript
import { createStore } from 'vuex'

export default createStore({
  state: {
    students: [{ name: 'mjy', age: '18'}, { name: 'cjy', age: '22'}, { name: 'ajy', age: '21'}]
  },
  getters: {
    more20stu (state) { return state.students.filter(item => item.age >= 20)}
  }
})
```

使用 通过`$store.getters.方法名` 进行调用

```javascript
//...template
<h2>{{$store.getters.more20stu}}</h2> // 展示出小于20岁的学生
```

getters 的入参, getters 可以接收两个参数，一个是 `state`, 一个是自身的 `getters` ，并对自身存在的方法进行调用

```javascript
getters: {
  more20stu (state, getters) { return getters.more20stu.length}
}
```

**getters 的参数与传参方法**

```javascript
getters: {
  more20stu (state, getters) { return getters.more20stu.length},
  moreAgestu (state) {
      return function (Age) {
        return state.students.filter(item =>
          item.age >= Age
        )
      }
    }
  // 该写法与上边写法相同但更简洁，用到了ES6中的箭头函数，如想了解es6箭头函数的写法
  // 可以看这篇文章 https://blog.csdn.net/qq_45934504/article/details/123405813?spm=1001.2014.3001.5501
  moreAgestu_Es6: state => {
    return Age => {
      return state.students.filter(item => item.age >= Age)
    }
  }
}
```

**使用**

```html
//...template
<h2>{{$store.getters.more20stu}}</h2> // 展示出小于20岁的学生
<h2>{{$store.getters.moreAgestu(18)}}</h2> // 通过参数传递, 展示出年龄小于18的学生
```

#### 5. `modules`

当应用变得复杂时，state中管理的变量变多，store对象就有可能变得相当臃肿。

为了解决这个问题，vuex允许我们将store分割成模块化（modules），而每个模块拥有着自己的state、mutation、action、getters等

在store文件中新建modules文件夹

在modules中可以创建单一的模块，一个模块处理一个模块的功能

store/modules/user.js 处理用户相关功能

store/modules/pay.js 处理支付相关功能

store/modules/cat.js 处理购物车相关功能

```javascript
// user.js模块
// 导出
export default {
  namespaced: true, // 为每个模块添加一个前缀名，保证模块命明不冲突 
  state: () => {},
  mutations: {},
  actions: {}
}
```

最终通过 `store/index.js` 中进行引入

```javascript
// store/index.js
import { createStore } from 'vuex'
import user from './modules/user.js'
import user from './modules/pay.js'
import user from './modules/cat.js'
export default createStore({
  modules: {
    user,
    pay,
    cat
  }
})
```

在template中模块中的写法和无模块的写法大同小异，带上模块的名称即可

```html
<h2>{{$store.state.user.count}}</h2>
```

```javascript
store.commit('user/sum', num) // 参数带上模块名称
store.dispatch('user/sum_actions', sum)
```

vue2**初次使用**

```javascript
const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // 变更状态
      state.count++
    },
    incrementNum (state,num) {
      // 通过提交载荷传递过来的num
      state.count+=num
    }
  }
})


//在组件中定义一个方法通过$store.commit('increment')来进行提交
methods:{
    increment(){
        this.$store.commit('increment')
    },
    incrementNum(num){
        this.$store.commit('increment',num)
    } 
}
```

### 提交载荷

mutations接受commit传递过来的参数，这个参数叫做payload（提交载荷），我们可以通过payload来实现数据的传递。

```javascript
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}

store.commit('increment', {
  amount: 10
})
```

### 对象风格的提交方式

store.commit()提供了另一种提交风格，store.commit()允许以对象的风格进行提交，这个风格跟vue很切合，对象声明形式。

```javascript
store.commit({
  type: 'increment',       //对应commit第一个参数，也就是事件类型
  amount: 10			//传递的参数payload
})
```

```javascript
mutations: {
  increment (state, payload) {    //对象提交方式，payload是提交载荷
    state.count += payload.amount
  }
}
```

**+=和=+的区别**

```javascript
+= 是简写，a += 1就是a = a+1
=+并不是简写，a =+ a直接对a的赋值，±符号代表的是正负（完全可以省略不写），即a =+ b其实就是a = b。
```

**Vue3中简单使用vuedraggable拖拽/ https://www.itxst.com/vue-draggable/j6vzfv6r.html /---官方文档**

**一、安装引入**

```javascript
// 安装插件
npm i vuedraggable@4.1.0 --save
// 导入插件
import Draggable from 'vuedraggable';
```

**二 、使用**

```javascript
<template>
   <div class="main">
            <Draggable v-model="tags" :list="state.list" :animation="100" item-key="id" class="list-group"
                :forceFallback="true" ghost-class="ghost" @change="onMoveCallback" :move="getdata">
                <template #item="{ element }">
                    <div class="card">
                        <img class="img" :src="element.cover" alt="">
                        <div class="id">NO.{{element.id}}</div>
                        <div class="bottom">

                        </div>
                    </div>
                </template>
            </Draggable>
        </div>
</template>

<script setup>
import { reactive} from 'vue';
import Draggable from 'vuedraggable';
const state = reactive({
    list:[
        {
        label: '模块1',
        id: 1,
        isflod: false,
      },
      {
        label: '模块2',
        id: 2,
        isflod: false,
      },
      {
        label: '模块3',
        id: 3,
        isflod: false,
      },
      {
        label: '模块4',
        id: 4,
        isflod: false,
      },
      {
        label: '模块5',
        id: 5,
        isflod: false,
      },
      {
        label: '模块6',
        id: 6,
        isflod: false,
      },
    ]
});
const onMoveCallback = (val) => {
      console.log('拖动前的索引 :' + val.moved.newIndex);
      console.log('拖动后的索引 :' + val.moved.oldIndex);
};
const getdata = (val) => {
      console.log(val.draggedContext.element.id);
};
</script>

<style   scoped>
.main{
    width:100%;
    height:30%;
}
.list-group{
    width: 100%;
    height: 100%;
    display:flex;
    flex-wrap: wrap;
}
.drawer_left {
    position: fixed;
    left: -350px;
    top: 0;
    width: 300px;
    height: 100%;
    z-index: 500;
    background-color: #cce7f8;
    display: flex;
    align-items: center;
    justify-content: center;
}

.card {
    width: 200px;
    height: 100%;
    position: relative;
    box-sizing: border-box;
    cursor: pointer;
    box-shadow: 0px 5px 10px 5px black;
    margin: 15px;
}
</style>
```

**sessionStorage**

```javascript
const ruleForm = reactive({
  account: "",
  password: "",
  name:"张卓飞",
  img:zzf
});
sessionStorage.setItem("Loginuser", JSON.stringify(ruleForm));  //存
JSON.parse(sessionStorage.getItem("Loginuser")).name; || JSON.parse(sessionStorage.getItem("Loginuser")).img;  //取
sessionStorage.removeItem("Loginuser"); //删
```

**路由传参**

```javascript
router.push({name:"wzry",params:{list: JSON.stringify(item)}}) //传
const listdate=ref('')
listdate.value=JSON.parse(route.params.list)
console.log(listdate.value.name); //取
```

**display**

```javascript
display:inline就是将元素显示为行元素
内联(display:inline;)元素不能设置宽高，因为内联属于行布局，其特性是在一行里进行布局，所以不能被设定宽高
 display:inline就是将元素显示为行内元素.
例如一个<div>test</div><div>test</div>默认会占2行,如果设置display:inline;,就会在一行内显示 

display:block就是将元素显示为块级元素
display:block  意思是：让对象成为块级元素(比如a，span等)。
一般的块级元素诸如段落<p>、标题<h1><h2>...、列表<uL><ol><dl> 、表格<table>、表单<form>、DIV<div>和BODY<body>等元素。而内联元素则如: 表单元素<input>、超级链接<a>、图像<img>、<span> ........
块级无素的显著特点是：每个块级元素都是从一个新行开始显示，而且其后的无素也需另起一行进行显示。

display:inline-block就是将元素显示为行内块元素
inline-block可以说是结合了inline和block的部分属性，最大的特点便是可以使元素在一行上显示 ，又能够改变元素的height，width的值. 使用padding，margin的top，left，bottom，right都能够撑开元素。

display:none是隐藏元素
display:hidden;
```

**setTimeout与setInterval的区别**

1.setTimeout(loop,3000)和setInterval(loop,3000)这两个函数的作用都是隔3秒执行loop这个函数，

两者的差距的是：setTimeout()只执行一次那段代码，而setInterval()在执行完一次代码之后，经过了3秒，它还会自动重复执行loop函数（类似于递归）

例如：

1、setInterval(loop,3000)，在执行完一次代码后，它自己会自动执行

```javascript
setInterval(loop,3000);
function loop(){
    alert("需要执行的代码");
}
```

2、如果setTimeout(loop,3000);需要进行循环执行的话,需要使用递归的方法 

```javascript
function loop(){
    alert("执行的代码");
    setTimeout(loop,3000);
}
```

其中两者的区别是，setInterval(loop,3000)是经过3秒执行一次，不会随着loop里面函数的变化而变化，但是setTimeout(loop,3000)

表示loop函数执行完后，经过三秒后在执行loop，如果loop函数执行需要1秒，那么整个循环执行之间相隔4秒。

场景：所以对于明确一定时间内进行循环的使用setInterval函数，但是如果不想由于连续调用产生互相干扰的问题，尤其是每次函数的调用需要繁重的计算以及很长的处理时间，那么最好使用setTimeout。

另外清除定时器，clearInterval(interValid)

**深层**

**setTimeout定义和用法**

setTimeout() 方法用于在指定的毫秒数后调用函数或计算[表达式](https://so.csdn.net/so/search?q=表达式&spm=1001.2101.3001.7020)。setTimeout 方法接收两个参数，第一个参数为回调函数函数或字符串，第二个参数为触发时间(单位：毫秒)

**setInterval()定义和用法**

setInterval() 方法可按照指定的周期(以毫秒计)来调用函数或计算表达式。

setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。

注意事项：

(1)setInterval()无视代码错误

如果setInterval执行的代码由于某种原因出错，它还会持续不断地调用该代码。

(2)setInterval无视网络延迟

假设你每隔一段时间就通过Ajax轮询一次服务器，看看有没有新数据。而由于某些原因(服务器过载、临时断网、流量剧增、用户带宽受限，等等)，你的请求要花的时间远比你想象的要长。但setInterval不在乎。它仍然会按定时持续不断地触发请求，最终你的客户端网络队列会塞满Ajax调用。

(3)setInterval不保证执行

与setTimeout不同，你并不能保证到了时间间隔，代码就准能执行。如果你调用的函数需要花很长时间才能完成，那某些调用会被直接忽略。


**settimeout和setinterval区别**

setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式,而setInterval()则可以在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval把它清除。

也就是说setTimeout()只执行一次，setInterval()可以执行多次。

两个函数的参数也相同，第一个参数是要执行的code或句柄，第二个是延迟的毫秒数。

**定时器例子：**

**1.**

```javascript
const number = ref(3)
const timer = ref(null)
const video = () => {
    clearInterval(timer.value)
    timer.value = null
    if(!timer.value) {
      timer.value = setInterval(() => {
        number.value--
        if( number.value <= 0 ) {
          clearInterval(timer.value)
          number.value = 3
        }
      },1000)
    }
}
```

2.

```html
<template>
    <div class="setTimeout">
        <el-button type="primary" @click="timmer">倒计数字</el-button>
        <span>{{number >=10 ? number : '0' + number}}</span>
        <el-button type="primary" @click="timmers">倒计时</el-button>
        <span>{{viewtime}}分</span>
    </div>
</template>
```

```javascript
//倒计数字
const number=ref(15)
//控制倒计数字的函数
const timmer=()=>{
    const timer = setTimeout(()=>{
        if(number.value > 0){
            number.value--
            timmer()
        }else{
            clearTimeout(timer);
            warningmessage("倒计数字结束")
        }
    },1000)
}
//数据层操作的倒计时
const maxtime=ref(300)
//视图层渲染的倒计时
const viewtime=ref()
//控制倒计时的函数
const timmers=()=>{
    const timer=setTimeout(() => {
        let moutine=Math.floor(maxtime.value/60)>=10 ? Math.floor(maxtime.value/60) : '0' + Math.floor(maxtime.value/60)
        let seconds=Math.floor(maxtime.value%60)>=10 ? Math.floor(maxtime.value%60) : '0' + Math.floor(maxtime.value%60)
        let ss = moutine + ': ' + seconds
        viewtime.value = ss
        if(maxtime.value > 0){
            maxtime.value--
            timmers()
        }else{
            clearTimeout(timer)
            warningmessage("倒计时结束")
        }
    },1000)
}
```

**window**

```javascript
window.location.reload() // 强制刷新 (true)
window.location="http://localhost:8081/" // 跳转到http://localhost:8081/
window.location.href="http://localhost:8081/setTimeout" // 跳转到http://localhost:8081/
window.open("https://www.baidu.com/")
```

**解决v-for循环<el-input></el-input>和<el-select></el-select>v-model双向绑定一个改变都改变的问题**

**html:**

```html
<div class="input" v-for="(item, index) in state.data" :key="index">
            <el-input v-model="item.input" placeholder="Please input" clearable />
            <el-select v-model="item.scroe" placeholder="Select">
                <el-option v-for="item in options" :key="item.value" :label="item.label" :value="item.value" />
            </el-select>
</div>
```

**script:**

```javascript
const state = reactive({
    data: [
        {
            scroe: null,
            input: null
        },
        {
            scroe: null,
            input: null
        },
        {
            scroe: null,
            input: null
        },
        {
            scroe: null,
            input: null
        },
        {
            scroe: null,
            input: null
        }
    ]
});
const options = ref([
    {
        value: 'Option1',
        label: 'Option1',
    },
    {
        value: 'Option2',
        label: 'Option2',
    },
    {
        value: 'Option3',
        label: 'Option3',
    },
    {
        value: 'Option4',
        label: 'Option4',
    },
    {
        value: 'Option5',
        label: 'Option5',
    },
])
```

**css:**

```scss
.input {
        width: 20%;
        height: auto;
        margin: 0 auto;

        .el-input {
            margin-top: 20px;
        }
    }
```

https://blog.csdn.net/qq_45444035/article/details/125484198 // vue word PDF Excel 预览

**js 秒数转换为时分秒**

```javascript
function formatSecToDate(sec){
    if(!sec){
        return '-'
    }
    var min = Math.floor(sec%3600);//分钟
    return Math.floor(sec/3600) + "时" + Math.floor(min/60) + "分"+ sec%60 + "秒";
}
```

**vue3获取Excel后台返回的地址渲染到页面**

**html:**

```html
<div class="excel-view-container">
       <el-button type="primary" @click="downloadxlsx">Excel</el-button>
       <div id="excelView" v-html="excelView"></div>
</div>
```

**script:**

```javascript
import axios from 'axios'
const XLSX = require('xlsx')
const excelView = ref('')
const downloadxlsx = () => {
    axios
        .request({
            method: "GET",
            url: 'http://192.168.11.16:7703/safe-file-b2/files/B2/xlsx/1659666747290/%E8%91%A3%E5%AE%B6%E5%8F%A3%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%8F%A3%E4%BA%BA%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F.xlsx', //路径
            responseType: "arraybuffer", //告诉服务器想到的响应格式
            headers: {
                "Content-Type":
                    "application/vnd.ms-excel;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            },
        })
        .then((res) => {
            console.log(res);
            const workbook = XLSX.read(new Uint8Array(res.data), {
                type: "array",
            }); // 解析数据
            const worksheet = workbook.Sheets[workbook.SheetNames[0]]; // workbook.SheetNames 下存的是该文件每个工作表名字,这里取出第一个工作表
            excelView.value = XLSX.utils.sheet_to_html(worksheet); // 渲染
            nextTick(() => {
                // DOM加载完毕后执行，解决HTMLConnection有内容但是length为0问题。
                setStyle4ExcelHtml();
            });
        })
}
const setStyle4ExcelHtml = () => {
    const excelViewDOM = document.getElementById("excelView");
    if (excelViewDOM) {
        const excelViewTDNodes = excelViewDOM.getElementsByTagName("td"); // 获取的是HTMLConnection
        if (excelViewTDNodes) {
            const excelViewTDArr = Array.prototype.slice.call(excelViewTDNodes);
            for (const i in excelViewTDArr) {
                const id = excelViewTDArr[i].id; // 默认生成的id格式为sjs-A1、sjs-A2......
                if (id) {
                    const idNum = id.replace(/[^0-9]/gi, ""); // 提取id中的数字，即行号
                    if (idNum && (idNum === "1" || idNum === 1)) {
                        // 第一行标题行
                        excelViewTDArr[i].classList.add("class4Title");
                    }
                    if (idNum && (idNum === "2" || idNum === 2)) {
                        // 第二行表头行
                        excelViewTDArr[i].classList.add("class4TableTh");
                    }
                }
            }
        }
    }
}
```

**scss1.:**

```scss
 .excel-view-container {
        width: 70% !important;
        height: 600px !important;
        margin: 0 auto;
        background-color: #ffffff;
        overflow: hidden;
        overflow-y: scroll;
        display: flex;
        align-items: center;
        flex-direction: column;
        margin-top: 15px;

        :deep(table) {
            width: 100% !important;
            border-collapse: collapse !important;
            border-spacing: 0 !important;
            text-align: center !important;
            border: 0px !important;
            overflow-x: auto !important;
        }

        :deep(table) {
            tr {
                td {
                    border: 1px solid gray !important;
                    width: 300px !important;
                    height: 33px !important;
                }
            }
        }

        :deep(.class4Title) {
            font-size: 22px !important;
            font-weight: bold !important;
            padding: 10px !important;
        }

        /**表格表头样式 */
        :deep(.class4TableTh) {
            font-weight: bold !important;
            padding: 2px !important;
            background-color: #ccc !important;
        }

    }
```

**scss2.:**

```scss
.excel-view-container {
            width: 100% !important;
            height: 100% !important;
            background-color: #ffffff;
            overflow: hidden;
            overflow-y: scroll;

            /deep/ table {
              width: 100% !important;
              border-collapse: collapse !important;
              border-spacing: 0 !important;
              text-align: center !important;
              border: 0px !important;
              overflow-x: auto !important;
            }

            /deep/ table tr td {
              border: 1px solid gray !important;
              width: 300px !important;
              height: 33px !important;
            }

            /deep/ .class4Title {
              font-size: 22px !important;
              font-weight: bold !important;
              padding: 10px !important;
            }

            /**表格表头样式 */
            /deep/ .class4TableTh {
              font-weight: bold !important;
              padding: 2px !important;
              background-color: #ccc !important;
            }

          }
```

**vue2获取Excel后台返回的地址渲染到页面**

**html:**

```html
<template>
    <div class="xlsx">
        <el-button type="primary" @click="download">下载</el-button>
        <div class="excel-view-container">
            <div id="excelView" v-html="excelView"></div>
        </div>
    </div>
</template>
```

**script:**

```javascript
<script>
import axios from 'axios'
const XLSX = require("xlsx");
export default {
    data() {
        return {
            excelView: ''
        }
    },
    methods: {
        download() {
            //表格
            var that = this;
            axios
                .request({
                    method: "GET",
                    url: 'http://192.168.11.16:7703/safe-file-b2/files/B2/xlsx/1659601120256/%E5%8D%B1%E9%99%A9%E6%BA%90%E8%BF%9B%E5%BA%A6.xlsx', //路径
                    responseType: "arraybuffer", //告诉服务器想到的响应格式
                    headers: {
                        "Content-Type":
                            "application/vnd.ms-excel;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    },
                })
                .then((res) => {
                    console.log(res);
                    const workbook = XLSX.read(new Uint8Array(res.data), {
                        type: "array",
                    }); // 解析数据
                    const worksheet = workbook.Sheets[workbook.SheetNames[0]]; // workbook.SheetNames 下存的是该文件每个工作表名字,这里取出第一个工作表
                    this.excelView = XLSX.utils.sheet_to_html(worksheet); // 渲染
                    this.$nextTick(function () {
                        // DOM加载完毕后执行，解决HTMLConnection有内容但是length为0问题。
                        this.setStyle4ExcelHtml();
                    });
                })
        },
        setStyle4ExcelHtml() {
            const excelViewDOM = document.getElementById("excelView");
            if (excelViewDOM) {
                const excelViewTDNodes = excelViewDOM.getElementsByTagName("td"); // 获取的是HTMLConnection
                if (excelViewTDNodes) {
                    const excelViewTDArr = Array.prototype.slice.call(excelViewTDNodes);
                    for (const i in excelViewTDArr) {
                        const id = excelViewTDArr[i].id; // 默认生成的id格式为sjs-A1、sjs-A2......
                        if (id) {
                            const idNum = id.replace(/[^0-9]/gi, ""); // 提取id中的数字，即行号
                            if (idNum && (idNum === "1" || idNum === 1)) {
                                // 第一行标题行
                                excelViewTDArr[i].classList.add("class4Title");
                            }
                            if (idNum && (idNum === "2" || idNum === 2)) {
                                // 第二行表头行
                                excelViewTDArr[i].classList.add("class4TableTh");
                            }
                        }
                    }
                }
            }
        },
    }
}
</script>
```

**css:**

```css
<style scoped>
.xlsx {
    width: 100%;
    height: 100%;
}

.excel-view-container {
    width: 100% !important;
    height: 100% !important;
    background-color: #ffffff;
    overflow: hidden;
    overflow-y: scroll;
}

.excel-view-container /deep/ table {
    width: 100% !important;
    border-collapse: collapse !important;
    border-spacing: 0 !important;
    text-align: center !important;
    border: 0px !important;
    overflow-x: auto !important;
}

.excel-view-container /deep/ table tr td {
    border: 1px solid gray !important;
    width: 300px !important;
    height: 33px !important;
}

.excel-view-container /deep/ .class4Title {
    font-size: 22px !important;
    font-weight: bold !important;
    padding: 10px !important;
}

/**表格表头样式 */
.excel-view-container /deep/ .class4TableTh {
    font-weight: bold !important;
    padding: 2px !important;
    background-color: #ccc !important;
}
</style>
```

**vue 样式穿透 >>>、/deep/ 、::v-deep 、:deep(<inner-selector>)应用场景注意事项**

**1、>>>**

```javascript
如果项目使用的是css 原生样式,那么你可以直接使用 >>> 穿透修改
<style scoped>
/*编译前*/
.a >>> .b { 
 /* ... */
}

/*编译后*/
.a[data-v-f3f3eg9] .b { /* ... */ }
</style>
```

**2、/deep/**

```javascript
项目中用到了预处理器 scss 、sass、less 操作符 >>> 可能会因为无法编译而报错 。可以使用 /deep/
注意：vue-cli3以上版本不可以
<style lang="scss" scoped>
/*用法1*/
.a {
 /deep/ .b { 
  /* ... */
 }
} 
/*用法2*/
.a /deep/ .b { 
  /* ... */
 }
</style>
```

**3、::v-deep**

```javascript
如果使用了预处理器都可以使用 ::v-deep
<style lang="scss" scoped>
/*用法1*/
.a{
 ::v-deep .b { 
  /* ... */
 }
} 
/*用法2*/
.a ::v-deep .b {
  /* ... */
}
</style>
```

**4、:deep(<inner-selector>)**

```javascript
[@vue/compiler-sfc]::v-deep usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead.

::v-deep 用作组合器已被弃用。 使用 :deep(<inner-selector>) 代替。
```

**delete**

**vue2**

```javascript
 data : {
        namelist : {
           id : 1, 
           name : '叶落森'
        }       
}
// 删除name
delete this.namelist.name;//js方法
Vue.delete(this.namelist,'name');//vue方法
```

**JS**

```javascript
<script> 
      var a=[1,2,3,4] 
      var obj=[1,2,3,4] 
      delete a[1] 
      console.log(a) 
      vue.delete(obj,1) 
      console.log(obj); 
</script>
```

**Watch**

watch函数收三个参数：

1. 需要进行监听的数据的数组，
2. 监听的数据发生改变时的回调
3. 配置项

- 情况一（监视一个数字的变化）

```javascript
let count = ref(0) 
watch(count,(newV,oldV)=>{
    console.log(newV,oldV);
})
```

情况二（监听俩个数据的变化）

```javascript
let year = ref(2000) 
let age = ref(22) 
function count(){
    year.value++
    age.value++
}
watch([year,age],(newV,oldV)=>{
    console.log(newV,oldV);
})
```

加入配置项参数



```javascript
let year = ref(2000) 
let age = ref(22) 
function count(){
    year.value++
    age.value++
}
watch([year,age],(newV,oldV)=>{
    console.log(newV,oldV);
},{immediate:true})  //设置立即监听
```

情况三（监听reactive管理的对象的变化）

```javascript
const student = reactive({
       name:'张三',
       age:20,
       a:{
           b:{
               salary:'20k'
           }
       }
  })
function changeName(){
    student.name = student.name + '@'
}
function changeAge(){
    student.age ++
}
function changeSalary(){
    student.a.b.salary = "50k"
}
watch(student,(newV,oldV)=>{
    console.log(newV,oldV);
})
```

注意：此时的oldValue失效，在监听深层次的数据时依旧可以监听到变化，可以看出vue3默认开启了深度监视

- 情况4（监听对象中的某个属性）

  ```javascript
  //上方代码watch改写为
  watch(()=>student.name,(newValue,oldValue)=>{
      console.log(newValue,oldValue);
  })
  ```

  监听对象的某个属性需要将watch函数的第一个参数写为一个函数需要监听的属性作为返回值，可以正确的获得oldValue

  

情况5（监听对象的某些属性）

```javascript
//watch改写为
watch([()=>student.name,()=>student.age],(newValue,oldValue)=>{
    console.log(newValue,oldValue);
})
```

监听对象的一些属性传入的第一个参数是存放返回对象属性的函数的数组，oldValue有效

情况6（监听对象套很深的对象的属性）

```javascript
const student = reactive({
  a: {
    b: {
      salary: "20k",
    },
  },
});
function changeSalary() {
  student.a.b.salary = "50k";
}
watch(
  () => student.a,
  (newValue, oldValue) => {
    console.log(newValue, oldValue);
  },
  { deep: true }
);
```

监听对象嵌套很深需要开启深度监听，oldValue不好使

**computed**

```javascript
基本用法：
const openTab = computed(() => { return store.state.openTab }) ||
const openTab = computed(()=> store.state.openTab)
```

```javascript
computed使用get和set：
const activeIndex = computed({ 
  get(){
    return store.state.activeIndex
  },
  set(val){
    return store.commit('set_active_index', val)
  }
})
```

**window**

```javascript
window.location.href="地址" // 在本页面跳转到新页面
window.open("地址") // 打开新窗口跳转到新页面
```

**new Date()的属性**

### 一、 所有日期处理如下

```javascript
var date = new Date();  
1. date.getFullYear(); //返回完整的年份(4位, 比如现在 2021)
2. date.getMonth()+1; //返回当前月份(0-11,0代表一月) 月份没有0月所以必须加1
3. date.getDate(); //返回当前日期(1-31)
4. date.getDay(); //返回当前星期几(从0开始0-6,0为星期一)
5. date.getTime(); //返回当前时间的毫秒数(从1970.1.1开始)
6. date.getHours(); //获取当前小时数(0-23)
7. date.getMinutes(); //获取当前分钟数(0-59)
8. date.getSeconds() //获取当前秒数(从0-59)
9. date.getMilliseconds(); //获取当前毫秒数(0-999) 
10. date.toLocaleDateString(); //获取当前日期
11. date.toLocaleTimeString(); //获取当前时间
12. date.tolocaleString(); //获取日期与时间
```

### 二、将字符串形式的日期转换成日期对象

```javascript
1. var nowTime = "2021-05-10"
2. var date = new Date(Date.parse(nowTime.replace(/-/g,"/"))) //2021/5/10
```

### 三、JS获取当前时间戳的方法-JavaScript 获取当前毫秒时间戳有以下三种方法

```javascript
var timestamp =Date.parse(new Date()); 结果1280977330000  //不推荐; 毫秒改成了000显示 
 
var timestamp =(new Date()).valueOf();   结果：1280977330748       //推荐;  
 
var timestamp=new Date().getTime();    结果：1280977330748        //推荐;  
```

### 四、日期格式转为日期标准字符串

```javascript
var formatDate = function (date) { 
     var y = date.getFullYear(); 
     var m = date.getMonth() + 1; 
     m = m < 10 ? '0' + m : m; 
     var d = date.getDate(); 
     d = d < 10 ? ('0' + d) : d; 
     return y + '-' + m + '-' + d; 
}; 
var arr = new Date()
formatDate(arr)  //出现当前时间和日期
```

**五、在页面显示时间GO**

```html
<div class="showTime">{{ t }}</div>
```

```javascript
const t = ref('');
const times = () => {
  //获取当前时间
  let nowDate = new Date();
  //获取当前年月日时分秒
  let date = {
    year: nowDate.getFullYear(),
    month: nowDate.getMonth() + 1,
    date: nowDate.getDate(),
    hh: nowDate.getHours(),
    mm: nowDate.getMinutes(),
    ss: nowDate.getSeconds(),
  };
  let year = nowDate.getFullYear();
  let newmonth = date.month >= 10 ? date.month : "0" + date.month;
  let day = date.date >= 10 ? date.date : "0" + date.date;
  let hh = date.hh >= 10 ? date.hh : "0" + date.hh;
  let mm = date.mm >= 10 ? date.mm : "0" + date.mm;
  let ss = date.ss >= 10 ? date.ss : "0" + date.ss;
  let timemm = year + "-" + newmonth + "-" + day + " " + hh + ":" + mm + ":" + ss;
  t.value = timemm;
  setTimeout(() => {
    times()
  }, 1000)
};

onMounted(() => {
  times()
});
```

**六、返回的方法是时间**

```javascript
times() {
	let nowDate = new Date();
	let date = {
		year: nowDate.getFullYear(),
		month: nowDate.getMonth() + 1,
		date: nowDate.getDate(),
		hh: nowDate.getHours(),
		mm: nowDate.getMinutes(),
		ss: nowDate.getSeconds(),
	};
	let yy = date.year
	let newmonth = date.month >= 10 ? date.month : "0" + date.month;
	let day = date.date >= 10 ? date.date : "0" + date.date;
	let hh = date.hh >= 10 ? date.hh : "0" + date.hh;
	let mm = date.mm >= 10 ? date.mm : "0" + date.mm;
	let ss = date.ss >= 10 ? date.ss : "0" + date.ss;
	let timemm = hh + ':' + mm + ':' + ss;
	return timemm;
},
```

**七、根据不同时间段返回不同的问候语**

```javascript
//根据不通时间段返回不同的问候语
const time = ref("");
const getTimeState = () => {
  // 获取当前时间
  let date = new Date();
  // 获取当前小时
  let hours = date.getHours();
  // 设置默认文字
  let text = ""
  // 判断当前时间段
  if (hours >= 0 && hours <= 7) {
    text = "早上好"
    time.value = text
  } else if (hours > 7 && hours <= 11) {
    text = "上午好"
    time.value = text
  } else if (hours > 11 && hours <= 14) {
    text = "中午好"
    time.value = text
  } else if (hours > 14 && hours <= 19) {
    text = "下午好"
    time.value = text
  } else if (hours > 19 && hours <= 24) {
    text = "晚上好"
    time.value = text
  }
};
```

**switch用法**

```javascript
const txt = ref('')
onMounted(()=>{
    let date = new Date()
    let week = date.getDay()
    switch(week){
        case 0:
            let seven = '今天是周日';
            txt.value = seven;
            break;
        case 1:
            let one = '今天是周一';
            txt.value = one;
            break;
        case 2:
            let two = '今天是周二'
            txt.value = two;
            break;
        case 3:
            let three = '今天是周三'
            txt.value = three;
            break;
        case 4:
            let four = '今天是周四'
            txt.value = four;
            break;
        case 5:
            let five = '今天是周五'
            txt.value = five;
            break;
        case 6:
            let six = '今天是周六'
            txt.value = six;
            break;
    }
})
```

**VUE修饰符**

```javascript
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>

```

**前端分页**

```html
<template>
  <div class="users">
    <!-- <video src="@/assets/CGkaichang.mp4" controls="controls" autoplay="autoplay" loop="loop" :webkit-playsinline="true"
      ref="video"></video> -->
    <!-- 前端分页 -->
    <div v-for="item in data.list">
      {{ item.name }}</div>
    <el-pagination background layout="prev, pager, next" :total="data.total" :page-size="data.size"
      @current-change="currentChange" />
  </div>
  <!-- Excel导入功能 -->
  <div class="index">
    <el-button type="success">
      导入：
      <input class="file_uploader" type="file" accept=".xlsx, .xls" @input="onImportEx" />
      <!-- accept限定传入的文件格式 -->
    </el-button>
  </div>
  <!-- Excel导出功能 -->
  <div>
    <el-button type="primary" @click="getOutExcel">导出</el-button>
  </div>
  <!-- 表格 -->
  <el-table :data="formData.data" style="width: 100%" id="table">
    <el-table-column prop="id" label="id" width="180" />
    <el-table-column prop="name" label="name" width="180" />
    <el-table-column prop="notes" label="notes" />
  </el-table>
</template>
```

```javascript
<script setup>
import XLSX from 'xlsx'//导入的依赖包
import FileSaver from "file-saver";//导出的依赖包
import { ref } from 'vue'
const formData = ref({
  data: [],//导入的数据
})
//导出函数
const exportClick = () => {
  // 导出文件名
  const filename = "导出.xlsx";
  // 导出表格加id,通过id获取要导出的表单
  const a = XLSX.utils.table_to_book(document.getElementById("table"));
  const b = XLSX.write(a, {
    bookType: "xlsx",
    bookSST: true,
    type: "array",
  });
  try {
    FileSaver.saveAs(
      new Blob([b], {
        type: "application/octet-stream",
      }),
      filename
    );
  } catch (e) {
    console.log(e);
  }
  return b;
};

const getOutExcel = () => {
  exportClick();
}
//导入函数
const onImportEx = (file) => {
  const { files } = file.target;
  const fileReader = new FileReader(); // 创建FileReader 对象 读取文件
  fileReader.onload = (event) => {
    try {
      const { result } = event.target;
      // 二进制读取 excel表格对象
      const workList = XLSX.read(result, { type: "binary" });
      // 存储数据
      let data = [];
      for (let sheet in workList.Sheets) {
        if (workList.Sheets.hasOwnProperty(sheet)) {
          // 利用 sheet_to_json 方法将 excel 转成 json 数据
          data = data.concat(XLSX.utils.sheet_to_json(workList.Sheets[sheet]));
          // break; // 如果只取第一张表，就取消注释这行
        }
      }
      // 最终获取到并且格式化后的 json 数据
      data.forEach(e => {
        const list = {
          id: e.序号,
          name: e.姓名,
          notes: e.备注
        }
        formData.value.data.push(list)
      })
    } catch (error) {
      console.log("上传失败,err:", error);
    }
  };

  fileReader.readAsBinaryString(files[0]);
}




//前端分页功能
import ssr from '../../../public/json/Shikigami.json'
import { onMounted, ref } from "vue";
const data = ref({
  srrList: [],
  total: 0,
  size: 10,
  pageIndex: 1,
  list: []
})
onMounted(() => {
  data.value.srrList = ssr.ssr[0].list
  data.value.total = data.value.srrList.length
  currentChange()
})
const currentChange = (index) => {
  if (index) {
    data.value.pageIndex = index
    data.value.list = data.value.srrList.slice(
      (data.value.pageIndex - 1) * data.value.size,
      data.value.pageIndex * data.value.size
    );
    return
  }
  data.value.list = data.value.srrList.slice(
    (data.value.pageIndex - 1) * data.value.size,
    data.value.pageIndex * data.value.size
  );
}
</script>
```

```css
<style scoped>
.users {
  width: 100%;
  height: 100%;
  background: url('@/assets/img/index.jpg');
  background-size: 100%;
  overflow-y: hidden;
}

.users video {
  z-index: -1;
  margin: 5% 10%;
  overflow-x: auto;
}
</style>
```

**数字动画https://www.cnblogs.com/smart-elwin/p/15187168.html**

**vue2全局总线事件**

main.js

```javascript
import Vue from 'vue'
const bus = new Vue()
Vue.prototype.$bus = bus
```

A组件

```javascript
this.$bus.$emit('reset',10)
```

B组件

```javascript
this.$bus.$on('reset',(val) => {
		console.log(val);
})
```

**vue3全局总线事件**

```javascript
emit(name,data) 
//触发事件，两个参数：name：触发的方法名，data：需要传递的参数
on(name,callback) 
//绑定事件，两个参数：name：绑定的方法名，callback：触发后执行的回调函数
off(name) 
//解绑事件，一个参数：name：需要解绑的方法名
```

```javascript
Mitt是一个微型的 EventEmitter 库，在Vue3中，官方推荐使用它替代已经移除的EventBus
npm安装：npm install mitt --save
```

main.js

```javascript
import mitt from 'mitt'
const app = createApp(App)
const bus = mitt()
app.config.globalProperties.$bus = bus
```

A组件

```javascript
import { ref, reactive } from 'vue'
import { getCurrentInstance } from 'vue'
const cxt = getCurrentInstance() //相当于Vue2中的this
const bus = cxt.appContext.config.globalProperties.$bus
//emitMitt是click方法
const emitMitt = () => {
  bus.emit('printMessage', '我是B组件，我被A组件触发了')
}
```

B组件

```javascript
import {  getCurrentInstance, onBeforeUnmount , onMounted } from 'vue';
const cxt = getCurrentInstance()
const bus = cxt.appContext.config.globalProperties.$bus
onMounted(() => {
  bus.on('printMessage', (val) => {
    console.log(val)
  })
})
onBeforeUnmount(() => {
  bus.off('printMessage')
})
```

**CSS实现导航条溢出左右滑动效果**

```html
<div class="overflow">
        <div class="header">
            <div :class="currentIndex == index ? 'header_times' : 'header_time'" v-for="(item, index) in timearr" :key="index" @mouseenter="mouseenter(index)" @mouseleave="mouseleave">
                <div :class="mouseindex == index ? 'chineses' : 'chinese'" @click="res(index)">{{ item.time }}</div>
            </div>
        </div>
    </div>
```

```javascript
import { ref, reactive, watch, toRefs, defineComponent, onMounted, computed, nextTick } from 'vue'
import { useRouter, useRoute } from "vue-router"
import { useStore } from 'vuex'
const store = useStore();
const router = useRouter();
const route = useRoute();
const timearr = ref([
    {
        time: "2022年"
    },
    {
        time: "2021年"
    },
    {
        time: "2020年"
    },
    {
        time: "2019年"
    },
    {
        time: "2018年"
    },
    {
        time: "2017年"
    },
    {
        time: "2016年"
    },
    {
        time: "2015年"
    },
    {
        time: "2014年"
    },
    {
        time: "2013年"
    }
])
const currentIndex = ref(null)
const mouseindex = ref(null)
const res = (index) => {
    currentIndex.value = index
}
const mouseenter = (index) => {
    mouseindex.value = index
}
const mouseleave = () => {
    mouseindex.value = null
}
```

**第一种CSS**

```css
.overflow {
    width: 100vw;
    height: 100%;
}

.header {
    width: 100%;
    height: 4%;
    position: fixed;
    overflow: hidden;
    overflow-x: scroll;
    white-space: nowrap; /* 不换行 */
}

.header_time {
    width: 80px;
    height: 90%;
    display: inline-block;
    background-color:white;
    border-radius: 50px;
    box-sizing: border-box;
    margin-left: 20px;
}

.header_times {
    width: 80px;
    height: 100%;
    display: inline-block;
    background-color:#79bbff;
    border-radius: 50px;
    box-sizing: border-box;
    margin-left: 20px;
}

.chinese{
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}
.chineses{
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    border-bottom: 1px solid black;
}
```

**第二种CSS**

```css
.overflow {
    width: 100vw;
    height: 100%;
}

.header {
    width: 100%;
    height: 4%;
    position: fixed;
    display: grid;
    grid-template-columns: 5fr 5fr 5fr 5fr 5fr 5fr 5fr 5fr 5fr 5fr;
    overflow: hidden;
    overflow-x: scroll;
}

.header_time {
    width: 80px;
    height: 90%;
    background-color:white;
    border-radius: 50px;
    box-sizing: border-box;
    margin-left: 20px;
    display:flex;
    justify-content: center;
    align-items: center;
}
.chinese{
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}
.header::-webkit-scrollbar{
        display: none;
}

/* 溢出盒子的文字隐藏 */
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
```

overflow:hidden;overflow-x:scroll; || overfolw-y:scroll;无效？

注意：子元素不能浮动；

父元素不能使用display：[flex](https://so.csdn.net/so/search?q=flex&spm=1001.2101.3001.7020);

还有一种情况：就是自动换行了，，，试着加个white-space:nowrap;



**[vue3] provide - inject**

[[vue3\] provide - inject - 简书 (jianshu.com)](https://www.jianshu.com/p/0446053e0736)

app.vue

```javascript
<template>
  <div class="ap">
    <router-view v-if="isRouterAlive"/>
  </div>
</template>

<script setup>
import { onMounted, ref, watch, nextTick, provide , readonly } from "vue";//要引入方法
import { useRouter } from "vue-router";
// 局部组件刷新
const isRouterAlive = ref(true);
const reload = () => {
  isRouterAlive.value = false;
  nextTick(() => {
    isRouterAlive.value = true;
  });
};
const num = ref(0)
const add = () => {
  num.value++
}
provide("reload", reload);
provide("num",num);
provide("add",add);
</script>
```

其他页面

```javascript
import { ref, reactive, watch, toRefs, defineComponent, onMounted, computed, nextTick , inject } from 'vue'
const refresh = inject("reload");
const reload = () => {
    refresh()
    add()
}
const num = inject("num");
const add = inject("add");
onMounted(() => {
    getlist()
    nextTick(() => {
        console.log(num.value);
    })
})
```

**nprogress进度条在vue项目里的使用**

npm install -S nprogress

router.js

```javascript
import NProgress from 'nprogress'
router.beforeEach((to, from, next) => {
    NProgress.start()
    // 判断有没有登录
    let login = sessionStorage.getItem('Loginuser')
    if (!login) {
        if (to.name == "Home") {
            next();
        } else {
            router.push('/')
        }
    } else {
        next();
    }
});
router.afterEach(() => { NProgress.done() })
```

app.vue的style里面

```css
#nprogress {
 pointer-events: none;
}

#nprogress .bar {
 background-image: linear-gradient(45deg, #30cfd0 0%, #330867 100%);
 opacity: 0.75;
 position: fixed;
 z-index: 1031;
 top: 0;
 left: 0;
 width: 100%;
 height: 2px;
}
```

**Javascript汉字转拼音,中文转拼音**

npm地址:[pinyin-pro - npm (npmjs.com)](https://www.npmjs.com/package/pinyin-pro)

gitub地址:[GitHub - zh-lx/pinyin-pro: 中文转拼音、拼音音调、拼音声母、拼音韵母、多音字拼音、姓氏拼音、拼音匹配](https://github.com/zh-lx/pinyin-pro)

npm安装

```javascript
npm install pinyin-pro
```

yarn安装

```javascript
yarn add pinyin-pro
```

浏览器端使用

```javascript
import { pinyin } from 'pinyin-pro';
```

node端使用

```javascript
const { pinyin } = require('pinyin-pro');
```

参数

```javascript
pinyin(word, options) 接收两个参数
word：必填。String 类型，需要转化为拼音的中文
options：可选。Object 类型，用于配置各种输出形式，相关配置在后面有所介绍
```

基本用法

```javascript
import { pinyin } from 'pinyin-pro'; // 若为node环境请用require形式引入

// 获取带音调拼音
pinyin('汉语拼音'); // 'hàn yǔ pīn yīn'
// 获取不带声调的拼音
pinyin('汉语拼音', { toneType: 'none' }); // 'han yu pin yin'
// 获取声调转换为数字后缀的拼音
pinyin('汉语拼音', { toneType: 'num' }); // 'han4 yu3 pin1 yin1'
// 获取声母
pinyin('汉语拼音', { pattern: 'initial' }); // 'h y p y'
// 获取带音调韵母
pinyin('汉语拼音', { pattern: 'final' }); // 'àn ǔ īn īn'
// 获取不带音调韵母
pinyin('汉语拼音', { pattern: 'final', toneType: 'none' }); // 'an u in in'
// 获取音调为数字的韵母
pinyin('汉语拼音', { pattern: 'final', toneType: 'num' }); // 'an4 u3 in1 in1'
// 获取音调
pinyin('汉语拼音', { pattern: 'num' }); // '4 3 1 1'
```

结果输出为数组格式

通过在 options 参数中加入`type: 'array'`，可以以数组形式输出基本用法中的示例:

```javascript
// 获取带音调拼音
pinyin('汉语拼音', { type: 'array' }); // ["hàn", "yǔ", "pīn", "yīn"]
// 获取不带声调的拼音
pinyin('汉语拼音', { toneType: 'none', type: 'array' }); // ["han", "yu", "pin", "yin"]
// 获取声调转换为数字后缀的拼音
pinyin('汉语拼音', { toneType: 'num', type: 'array' }); // ["han4", "yu3", "pin1", "yin1"]
// 获取声母
pinyin('汉语拼音', { pattern: 'initial', type: 'array' }); // ["h", "y", "p", "y"]
// 获取带音调韵母
pinyin('汉语拼音', { pattern: 'final', type: 'array' }); // ["àn", "ǔ", "īn", "īn"]
// 获取不带音调韵母
pinyin('汉语拼音', { pattern: 'final', toneType: 'none', type: 'array' }); // ["an", "u", "in", "in"]
// 获取音调
pinyin('汉语拼音', { pattern: 'num', type: 'array' }); // ["4", "3", "1", "1"]
```

获取单个字的多音

只有单字可以获取到多音模式, 词语、句子无效。同样可以通过配置 options 选项获取数组形式、韵母等格式

```javascript
pinyin('好', { multiple: true }); // 'hǎo hào'
pinyin('好', { multiple: true, type: 'array' }); // ["hǎo", "hào"]
```

options配置

| 参数     | 说明                                                         | 类型    | 可选值                         | 默认值 |
| -------- | ------------------------------------------------------------ | ------- | ------------------------------ | ------ |
| pattern  | 输出的结果的信息（拼音 / 声母 / 韵母 / 音调）                | string  | pinyin / initial / final / num | pinyin |
| tone     | 音调输出形式(拼音符号 / 数字 / 不加音调)                     | string  | symbol / num / none            | symbol |
| type     | 输出结果类型（字符串/数组）                                  | string  | string / array                 | string |
| multiple | 输出多音字全部拼音（仅在 word 为长度为 1 的汉字字符串时生效） | boolean | true / false                   | false  |

**VUE3打包后刷新页面404问题**

[Vue3：刷新页面报错404的解决方法 - 掘金 (juejin.cn)](https://juejin.cn/post/7080886221882261518)

```javascript
import { createRouter, createWebHistory, createWebHashHistory } from 'vue-router'
const router = createRouter({
    // history: createWebHistory(process.env.BASE_URL),
    history: createWebHashHistory(),
    routes
})
```

把createWebHistory`换成`createWebHashHistory

# AOS

## 在滚动库上设置动画

[AOS - 在滚动库上制作动画 (michalsnik.github.io)](https://michalsnik.github.io/aos/)

安装AOS

```javascript
npm install aos --save
```

main.js

```javascript
import AOS from "aos";
import "../node_modules/aos/dist/aos.css";
createApp(App).use(store).use(router).use(ElementPlus).use(AOS).mount('#app')
```

使用

html

```html
<template>
    <div class="demo">
        <img src="../assets/bg.jpg" alt=""
            style="width: 100%; height: 100%;position: absolute;inset: 0;object-fit: cover; z-index: -1;" />
        <div class="BJ">
            <span>滚动条动画</span>
        </div>
        <div class="demos">
            <div data-aos="fade-down" class="img" data-aos-duration="2000"
                :style="`background: url(${URL.urlA}) no-repeat`"></div>
            <div data-aos="zoom-in-down" class="img" data-aos-duration="2000"
                :style="`background: url(${URL.urlB}) no-repeat`"></div>
            <div data-aos="flip-left" data-aos-easing="ease-out-cubic" class="img" data-aos-duration="2000"
                :style="`background: url(${URL.urlC}) no-repeat`"></div>
            <div data-aos="flip-right" class="img" data-aos-duration="2000"
                :style="`background: url(${URL.urlD}) no-repeat`"></div>
            <div data-aos="zoom-out-down" class="img" data-aos-duration="2000"
                :style="`background: url(${URL.urlE}) no-repeat`"></div>
            <div data-aos="fade-up" data-aos-anchor-placement="bottom-bottom" class="img" data-aos-duration="2000"
                :style="`background: url(${URL.urlF}) no-repeat`"></div>
        </div>
    </div>
</template>
```

script

```javascript
<script setup>
import {
    ref,
    defineEmits,
    defineProps,
    nextTick,
    reactive,
    onMounted,
    watch,
    computed,
    onUnmounted,
    onBeforeUnmount,
    defineExpose,
    provide,
    inject,
} from "vue";
import { useStore } from "vuex";
import AOS from "aos";
import { useRouter, useRoute } from "vue-router";
import { successmessage, errormessage } from "@/api/message.js";
const store = useStore();
const router = useRouter();
const route = useRoute();
const URL = reactive({
    urlA: require('../assets/bj1.jpg'),
    urlB: require('../assets/bj2.jpg'),
    urlC: require('../assets/bj3.jpg'),
    urlD: require('../assets/bj4.jpg'),
    urlE: require('../assets/bj5.jpg'),
    urlF: require('../assets/bj6.jpg')
})
onMounted(() => {
    AOS.init();
});
</script>

```

css

```css
<style scoped>
/* 设备分辨率最小宽度为768px时为PC */
@media only screen and (/*设备分辨率宽度*/min-device-width:768px) {
    .demo {
        width: 100%;
        height: 100%;
    }

    .BJ {
        width: 100%;
        height: 100%;
        background-color: #6472c2;
        opacity: 0.85;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 800;
        font-size: 100px;
    }

    .demos {
        width: 100%;
        height: 70%;
        display: flex;
        align-items: center;
    }

    .img {
        width: 440px;
        height: 330px;
        background-size: 100% 100%;
        margin: 10px;
    }
}
/* 设备分辨率最大宽度为768px时为移动端 */
@media only screen and (/*设备分辨率宽度*/max-device-width:768px) {
    .demo {
        width: 100%;
        height: 100%;
    }

    .BJ {
        width: 100%;
        height: 100%;
        background-color: #6472c2;
        opacity: 0.85;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 800;
        font-size: 30px;
    }

    .demos {
        width: 100%;
        height: auto;
        display: flex;
        align-items: center;
        flex-direction: column;
    }

    .img {
        width: 90%;
        height: 330px;
        background-size: 100% 100%;
        margin: 10px;
    }
}
</style>
```

**媒体查询**

```javascript
max-width || min-width/*网页宽度*/
//all不分类型 网页宽度最小为1500px为PC
@media all and (/*网页宽度*/min-width:1500px)
//all不分类型 网页宽度最大为1500px为移动端
@media all and (/*网页宽度*/max-width:1000px)
min-device-width || max-device-width /*设备分辨率宽度*/
/* 设备分辨率最小宽度为768px时为PC */
@media only screen and (/*设备分辨率宽度*/min-device-width:768px)
/* 设备分辨率最大宽度为768px时为移动端 */
@media only screen and (/*设备分辨率宽度*/max-device-width:768px)

max-width是网页宽度. max-device-width是设备分辨率宽度.
```

- **媒体类型**
- 媒体是用来区分设备类型的，如屏幕设备、打印设备等，其中手机、电脑、平板都属于屏幕设备。

| 类型名称   | 值     | 描述                    |
| ---------- | ------ | ----------------------- |
| 屏幕       | screen | 带屏幕的设备            |
| 打印预览   | print  | 打印预览模式            |
| 阅读器     | speech | 屏幕阅读模式            |
| 不区分类型 | all    | 默认值，包括以上3种情形 |

- **媒体特性**

- 媒体特性主要用来描述媒体类型的具体特征，如当前屏幕的宽高、分辨率、横屏或竖屏等。

  | 特性名称       | 属性                  | 值                    |
  | -------------- | --------------------- | --------------------- |
  | 视口的宽和高   | width、height         | 数值                  |
  | 视口最大宽或高 | max-width、max-height | 数值                  |
  | 视口最小宽或高 | min-width、min-height | 数值                  |
  | 屏幕方向       | orientation           | portrait 或 landscape |

- 逻辑符

- 连接媒体和媒体特性的固定词语，分别为 not、only、and。

  **not**

  不满足媒体特性时生效，对媒体类型和第一个and不生效（**相当于非！，\**将条件取反的同时，将and变为或\****）。

  注意：**使用时必须在@media后面并指定媒体类型且搭配有and且只能出现一次**

  **only**

  可防止旧版浏览器应用指定的样式，这些浏览器不支持带媒体特性的媒体查询。它对现代浏览器没有影响。

  注意：必须指定媒体类型。

  **and**

  将媒体特性与媒体类型或其他媒体特性组合在一起（**相当于且&&**）。
  
  **夏柔API接口（[夏柔的个人主页免费API - 提供免费接口调用平台 (aa1.cn)](https://api.aa1.cn/author/1)）**
  
  **自定义右键链接（[vue3-menus: Vue3.0 自定义右键菜单 (gitee.com)](https://gitee.com/longxinziyan/vue3-menus#单个菜单项参数menusitemoptions)）**

**根据id去重**

```javascript
//第一种用find方法
// 数组根据id去重
    let ARR = [
        {
            id: 0,
            name: "张三"
        },
        {
            id: 0,
            name: "张四"
        },
        {
            id: 1,
            name: "王五"
        },
        {
            id: 1,
            name: "张酒"
        },
        {
            id: 2,
            name: "黄二"
        },
        {
            id: 2,
            name: "吊毛"
        },
        {
            id: 3,
            name: "孙子"
        }
    ]
    let vs = []
    ARR.filter(item => {
        let v = !vs.find(row => {
            return row.id === item.id
        })
        if (v) {
            vs.push(item);
        }
        return vs
    })

    console.log(vs);

//第二种用reducce方法
var arr = [{
        key: '01',
        value: '乐乐'
    }, {
        key: '02',
        value: '博博'
    }, {
        key: '03',
        value: '淘淘'
    }, {
        key: '04',
        value: '哈哈'
    }, {
        key: '01',
        value: '乐乐'
    }];

    // 方法1：利用reduce方法遍历数组,reduce第一个参数是遍历需要执行的函数，第二个参数是item的初始值
    var obj = {};
    arr = arr.reduce(function (item, next) {
        obj[next.key] ? '' : obj[next.key] = true && item.push(next);
        return item;
    }, []);
    console.log(arr)
```

**根据对象属性来找对应的值**

```JavaScript
	var url = ''
    const actions = {
        'yh': 'http://10.161.54.105:8006',
        'w1': "",
        'jxr': 'http://10.156.46.90:8006',
        'ld': 'http://10.160.79.90:8006',
        'b2': 'http://10.144.107.96:8006',
        't7': "",
        'hq': "",
    }

    const urlMountProto = (cm) => {
        //if (cm) false;
        const key = cm.toLocaleLowerCase()
        if (actions[key]) {
            url = actions[key]
        }
    }
    urlMountProto('ld')
    console.log(url);


const pictureNum = reactive({
  '未立项': {
    src: "/images/ToDoItemIcon.png",
    color: "#ff7051",
  },
  '已撤回': {
    src: "/images/CanceledIcon.png",
    color: "#a8b0c9",
  },
  '申请中': {
    src: "/images/InProgressIcon.png",
    color: "#faab0d",
  },
  '已立项': {
    src: "/images/ToDoItemIcon.png",
    color: "#00c5b6",
  },
  '执行中': {
    src: "/images/InProgressIcon.png",
    color: "#faab0d",
  },
  '已结项': {
    src: "/images/ClosedIcon.png",
    color: "#98c41a",
  },
  '已取消': {
    src: "/images/CanceledIcon.png",
    color: "#a8b0c9",
  },
  '已延期': {
    src: "/images/IconInDelay.png",
    color: "#00c5b6",
  },
});

tableData.value = res.data.iPage.records.map((item) => {
    if (item.status != "" && item.status != null && item.status != undefined) {
      item.src = pictureNum[item.status].src;
      item.color = pictureNum[item.status].color;
    }
)}
```

# Vue3 + Photo-sphere-viewer 全景

安装

```javascript
npm install photo-sphere-viewer --save
```

index.html引入

```html
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photo-sphere-viewer@4/dist/photo-sphere-viewer.min.css"/>
<script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/uevent@2/browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photo-sphere-viewer@4/dist/photo-sphere-viewer.min.js"></script>
```

插件引用

```javascript
import { Viewer } from 'photo-sphere-viewer' // 引入插件
import 'photo-sphere-viewer/dist/photo-sphere-viewer.css' //引入CSS样式
```

创建容器

```html
<div id="viewer"></div>
```

页面使用

```javascript
// 全景视图
let panoramaViewer = null
// 全景图初始化
const initViewer = async function () {
  panoramaViewer = new Viewer({
    container: document.querySelector('#viewer'), // 容器
    panorama: img, // 全景图片地址
    navbar: [
      'autorotate',
      'zoom',
      'caption',
      'fullscreen'
    ],
    plugins: [], // 标记点
    size: {
      width: '100%',
      height: '100%'
    }
  })
}

onMounted(() => {
  initViewer()
})
```

**后端返回文件流前端导出为xlsx表格**

接口函数

```javascript
export const SourceOfMatterExport = (params) => {
    return instance.post('/supervise/superviseInfo/export', params, { responseType: 'arraybuffer' })
}
```

主体功能

```javascript
  const res = await SourceOfMatterExport(params);
  let blob = new Blob([res], {
    type: "application/vnd.ms-excel;charset=utf-8",
  });
  const Exportres = document.createElement("a");
  Exportres.style.display = "none";
  Exportres.href = window.URL.createObjectURL(blob);
  Exportres.setAttribute("download", "督查督办统计");
  document.body.appendChild(Exportres);
  Exportres.click();
  document.body.removeChild(Exportres);
```

**后端返回二进制流的图片**

接口函数

```javascript
export const QQBP = (params) => {
    return Network({
        method: 'GET',
        url: '/qqcardv1/',
        responseType:'blob',
        params
    })
}
```

主体功能

```javascript
const res = await QQBP(params)
console.log(res);
// 二进制流的图片，blob转换
let blob = new Blob([res])
let url = window.URL.createObjectURL(blob)
// img.value是img标签src地址图片地址
img.value = url
```

下载图片到本地

安装html2canvas

```javascript
npm install --save html2canvas
```

引入html2canvas

```javascript
import html2canvas from "html2canvas"
```

主体功能

```javascript
// 下载图片
html2canvas(document.getElementById('img_body'), {
    backgroundColor: "transparent",
    allowTaint: true,
}).then((canvas) => {
    console.log(canvas)
    // 将画布展示到最前端
    // canvas.id = 'canvas'
    // document.body.appendChild(canvas);
    // document.getElementById('canvas').style.position = 'fixed'
    // document.getElementById('canvas').style.top = '0'
    // document.getElementById('canvas').style.left = '0'
    // document.getElementById('canvas').style.zIndex = '9999'
    // // 下载图片到本地
    var url = document.createElement("a");
    url.href = canvas.toDataURL("image/jpg");
    url.download = 'QQ名片';
    url.click();
    success("下载成功")
}
);
```

**纯前端实现导出列表数据为xlsx**

安装

```javascript
npm install -S file-saver xlsx
npm i xlsx@0.18.0
```

新建文件夹utils

新建downloadexcel.js文件

```javascript
import fs from 'file-saver'
import XLSX from 'xlsx'
export default (json, fields, filename = '测试数据.xlsx') => {
    // console.log(json);
    // console.log(fields);

    json.forEach(item => {
        for (let i in item) {
            if (fields.hasOwnProperty(i)) {
                // if (item[i] instanceof Object) {
                // console.log(item[i] );
                // console.log(fields[i]);
                    
                // }

                item[fields[i]] = item[i];
            }
            delete item[i]; //删除原先的对象属性
        }
    })

    let sheetName = filename //excel的文件名称
    let wb = XLSX.utils.book_new()  //工作簿对象包含一SheetNames数组，以及一个表对象映射表名称到表对象。XLSX.utils.book_new实用函数创建一个新的工作簿对象。
    let ws = XLSX.utils.json_to_sheet(json, { header: Object.values(fields) }) //将JS对象数组转换为工作表。
    wb.SheetNames.push(sheetName)
    wb.Sheets[sheetName] = ws
    const defaultCellStyle = { font: { name: "Verdana", sz: 100, color: "FF00FF88" }, fill: { fgColor: { rgb: "FFFFAA00" } } };//设置表格的样式
    let wopts = { bookType: 'xlsx', bookSST: false, type: 'binary', cellStyles: true, defaultCellStyle: defaultCellStyle, showGridLines: true }  //写入的样式
    let wbout = XLSX.write(wb, wopts)
    let blob = new Blob([s2ab(wbout)], { type: 'application/octet-stream' })
    fs.saveAs(blob, filename + '.xlsx')
}
const s2ab = s => {
    if (typeof ArrayBuffer !== 'undefined') {
        var buf = new ArrayBuffer(s.length)
        var view = new Uint8Array(buf)
        for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) & 0xff
        return buf
    } else {
        var buf = new Array(s.length);
        for (var i = 0; i != s.length; ++i) buf[i] = s.charCodeAt(i) & 0xFF;
        return buf;
    }
}
```

页面使用

html

```html
      <el-button type="primary" :icon="Upload" @click="exportToExcel">导出</el-button>
```

script

```javascript
import exportExcel from "@/utils/downloadexcel.js";
// 导出
const exportToExcel = async () => {
  const { data } = await getHeroInfocard()
  console.log(data.herolist);
  data.herolist.map(item => {
    item.status = item.status === 0 ? '未通过' : item.status === 1 ? '审核中' : '已通过'
    return item
  })
  let params = {
    name: '英雄名字',
    Position: '英雄定位',
    title: '英雄称号',
    Specialty: '英雄特长',
    status: '审核状态',
    id: '英雄ID',
    money: '英雄价格',
    time: '英雄上架时间',
    story: '英雄背景故事',
    history: '英雄历史原型'
  }
  //data.herolist为列表数据
  exportExcel(data.herolist, params, '王者荣耀后台管理系统英雄基本信息')
}
```

**定位居中**

```css
width: 85%;
height: 60vh;
position: absolute;
z-index: 20;
background-color: white;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
border-radius: 10rpx;
```

**vue项目改成electron桌面端应用**

安装依赖

安装electron

```javascript
npm install electron -g
vue add electron-builder
```

安装完如果报错输入

```javascript
npm config set electron_mirror https://cdn.npm.taobao.org/dist/electron/

```

## 安装完成后：

来安装cnpm（https://registry.npmmirror.com 淘宝镜像 的地址）

```javascript
npm install -g cnpm --registry=https://registry.npmmirror.com
```

1.执行`npm run serve` **正常打开网页端项目**
2.执行`npm run electron:serve` **打开桌面端应用**

打包网页端

```javascript
npm run build
```

打包桌面端

```javascript
npm run electron:build
```

打包成桌面端需要ico必须转网址：[在线图片转icon格式 – 图片转换成icon在线工具 – 迅捷PDF转换器在线免费版 (xunjiepdf.com)](https://app.xunjiepdf.com/img2icon/)

##  隐藏客户端默认菜单

找到background.js

```javascript
修改import { app, protocol, BrowserWindow , Menu } from 'electron'
添加Menu.setApplicationMenu(null)
```

**Electron-Builder打包时报错could not find: “C:\Users\XX\AppData\Local\Temp\t-bDWVX6\0-messages.nsh“**

打开 node_module/app-builder-lib/out/targets/nsis/NsisTarget.js文件，在 executeMakensis 方法中加入我们所需的参数

```javascript
//node_module/app-builder-lib/out/targets/nsis/NsisTarget.js
async executeMakensis(defines, commands, script) {
    const args = this.options.warningsAsErrors === false ? [] : ["-WX"];
    //此处新增
    args.push("-INPUTCHARSET", "UTF8");
    //结束
    for (const name of Object.keys(defines)) {
      const value = defines[name];

      if (value == null) {
        args.push(`-D${name}`);
      } else {
        args.push(`-D${name}=${value}`);
      }
    }

```

vue.config.js配置文件

```javascript
pluginOptions: {
        electronBuilder: {
            builderOptions: {
                "appId": "com.example.app",
                "productName": "Code", //项目名，也是生成的安装文件名，即aDemo.exe
                "copyright": "zzf © 2023", //版权信息
                // "directories": {
                //     "output": "./dist_electron" //输出文件路径，之前编译的默认是dist_electron
                // },
                "win": {
                    "icon": "code.ico", //这里注意配好图标路径
                    "target": [{
                        "target": "nsis", //利用nsis制作安装程序
                        "arch": [
                            "x64", //64位
                            "ia32" //32位
                        ]
                    }]
                },
                "nsis": {
                    "oneClick": false, // 是否一键安装
                    "allowElevation": true, // 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。
                    "allowToChangeInstallationDirectory": true, // 允许修改安装目录
                    "installerIcon": "code.ico",// 安装图标
                    "uninstallerIcon": "code.ico",//卸载图标
                    "installerHeaderIcon": "code.ico", // 安装时头部图标
                    "createDesktopShortcut": true, // 创建桌面图标
                    "createStartMenuShortcut": true,// 创建开始菜单图标
                    "shortcutName": "code", // 图标名称
                }
                // options placed here will be merged with default configuration and passed to electron-builder
            }
        }
    }
```

如果npm run electron:build打包报错就先安装cnp淘宝镜像然后cnpm run electron:build就可以成功

如果报错缺少electron-v13.6.9-win32-x64.zip包，在C:\Users\Administrator\AppData\Local\electron\Cache路径添加photo-sphere-viewer项目里面的Cache里面的文件(都在gitee上面，从gitee上面下载下来就行)

**JS事件mouseover ,mouseout ,mouseenter,mouseleave的区别**

##### 一、mouseover和mouseenter

```javascript
mouseover: 只要鼠标指针移入事件所绑定的元素或其子元素，都会触发该事件
mouseenter: 只有鼠标指针移入事件所绑定的元素时，才会触发该事件（不支持冒泡）
```

如果一个元素**没有子元素**，那么该元素绑定`mouseover`或者`mouseenter`两种事件效果没有区别，鼠标每次移入元素时都只会触发一次事件；如果绑定了`mouseover`事件的元素**存在子元素**，那么，每次移入该元素时都会触发一次事件（包括从**外部移入**和从**子元素移入**），移入子元素时也会触发一次事件

##### 二、mouseout和mouseleave

```javascript
mouseout: 只要鼠标指针移出事件所绑定的元素或其子元素，都会触发该事件
mouseleave: 只有鼠标指针移出事件所绑定的元素时，才会触发该事件（不支持冒泡）
```

如果一个元素**没有子元素**，那么该元素绑定`mouseout`或者`mouseleave`两种事件效果没有区别，鼠标每次移出元素时都只会触发一次事件；如果绑定了`mouseout`事件的元素**存在子元素**，那么，每次移出该元素时都会触发一次事件（包括**移出至外部**和**移出至子元素**），从子元素移出时也会触发一次事件

###### onmousedown：事件会在鼠标按键被按下时发生(鼠标按下事件)

onmousemove：事件会在鼠标移动时触发(鼠标移动事件)

###### onmouseup：事件会在松开鼠标按键时触发(鼠标抬起事件)

###### onmouseout：属性在鼠标指针移动到元素外时触发

# Vue3 directive-自定义指令

## Vue3指令的钩子函数

created 元素初始化的时候

beforeMount 指令绑定到元素后调用 只调用一次

mounted 元素插入父级dom调用

beforeUpdate 元素被更新之前调用

update 这个周期方法被移除 改用updated

beforeUnmount 在元素被移除前调用

unmounted 指令被移除后调用 只调用一次

Vue2 指令 bind inserted update componentUpdated unbind

## 生命周期钩子参数详解

第一个 el 当前绑定的DOM 元素

第二个 binding

- instance：使用指令的组件实例。
- value：传递给指令的值。例如，在 v-my-directive="1 + 1" 中，该值为 2。
- oldValue：先前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否有更改都可用。
- arg：传递给指令的参数(如果有的话)。例如在 v-my-directive:foo 中，arg 为 "foo"。
- modifiers：包含修饰符(如果有的话) 的对象。例如在 v-my-directive.foo.bar 中，修饰符对
- 为 {foo: true，bar: true}。
- dir：一个对象，在注册指令时作为参数传递

第三个 当前元素的虚拟DOM 也就是Vnode

第四个 prevNode 上一个虚拟节点，仅在 beforeUpdate 和 updated 钩子中可用

[Vue3 directive-自定义指令 - 掘金 (juejin.cn)](https://juejin.cn/post/7170141308206448648)

**封装vue自定义拖拽指令**

HTML第一种

```html
        <div class="rect" v-drag></div>
```

HTML第二种

```html
		<div class="box_main" v-drag>
            <img class="img" src="../assets/阿备.jpg" alt="">
            <div class="id"><span>NO.51</span></div>
            <div class="bottom"><span>刘备</span><span>仁德义枪</span></div>
            <div class="main_img">
                <img src="../assets/51.png" alt="">
                <span class="span" @mouseenter="mouseenter" @mouseleave="mouseleave" :style="style"
                    @click="upd(item, index)">编辑英雄</span>
                <div class="line" :class="{ lineactive: lineactive }"></div>
                <el-button type="danger" @click="del(item, index)">删除英雄</el-button>
            </div>
        </div>
```

css第一种

```css
.rect {
    width: 100px;
    height: 100px;
    background-color: peru;
    position: absolute;
    mix-blend-mode: screen;
    cursor: pointer;
    background: url('../assets/zzf.png') no-repeat;
    background-size:100% 100%;
}
```

css第二种

```css
.box_main {
    width: 180px;
    height: 300px;
    margin-top: 1rem;
    margin-left: 15px;
    position: relative;
    word-break: break-all;
    word-wrap: break-word;
    box-shadow: 0px 5px 10px 5px black;
    cursor: pointer;
    transition: all 0.35s;
}

.box_main:hover {
    transition: all 0.35s;
    box-shadow: 0 10px 30px 5px black;
    transform: translateY(-10px);
    background-color: black;
}

.img {
    position: absolute;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.id {
    position: absolute;
    z-index: 1;
    color: white;
    margin: 15px;
    font-size: 16px;
    font-weight: 800;
}

.bottom {
    position: absolute;
    z-index: 1;
    color: white;
    bottom: 5px;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    justify-content: center;
    font-size: 16px;
    font-weight: 800;
    pointer-events: none;
    box-sizing: border-box;
}

@keyframes line {
    33% {
        transform: translateY(-10px);
    }

    75% {
        transform: translateY(5px);
    }

    100% {
        transform: translateY(0px)
    }
}

.box_main:hover .id {
    animation: line 0.5s 0.2s;
}

.box_main:hover .bottom {
    animation: line 0.5s 0.2s;
}

.main_img {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
    opacity: 0;
    backdrop-filter: blur(10px);
    transition: all 0.5s linear;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

.main_img img {
    border-radius: 50%;
}

.box_main:hover .main_img {
    opacity: 1;
    transition: all 0.5s 0.5s
}

.span {
    color: white;
    font-size: 25px;
    font-weight: 800;
}

.line {
    width: 0px;
    height: 3px;
    transition: all 0.5s linear;
}

.lineactive {
    width: 150px !important;
    background-color: skyblue;
    transition: all 0.5s 0.35s;
}

.el-button {
    margin-top: 10px;
}
```

css第二种的script里面的js

```javascript
const lineactive = ref(false)
const style = ref('')
const mouseenter = () => {
    lineactive.value = true
    style.value = 'color:#000a48'
}
const mouseleave = () => {
    lineactive.value = false
    style.value = 'color:white'
}
```

创建directive文件夹在里面创建directives.js

```javascript
// 拖拽的指令
// 实现拖拽主要是通过
// onmousedown：鼠标按下事件
// onmousemove：鼠标移动事件
// onmouseup：鼠标抬起事件 实现
const vDrag = {
  mounted (el,binding) {
      console.log(el,binding);
      el.onmousedown = (ev) => {
        console.log(ev);
        // 鼠标按下的位置
        const mouseXStart = ev.clientX;
        const mouseYStart = ev.clientY;
        // console.log("按下开始", mouseXStart, mouseYStart);
        // 当前滑块位置
        const rectLeft = el.offsetLeft;
        const rectTop = el.offsetTop;
        document.onmousemove = (e) => {
          // 鼠标移动的位置
          const mouseXEnd = e.clientX;
          const mouseYEnd = e.clientY;
          const moveX = mouseXEnd - mouseXStart + rectLeft;
          const moveY = mouseYEnd - mouseYStart + rectTop;
          // console.log(rectLeft, rectTop);
          el.style["top"] = moveY + "px";
          el.style["left"] = moveX + "px";
        };
        document.onmouseup = () => {
          // 取消事件
          document.onmousemove = null;
        };
      };
    }
  }
  // 挂载，注册
  const directives = {
    install (app) {
      app.directive('drag', vDrag)
    }
  };
  export default directives

      

```

最后在main.js全局引用

```javascript
import Directives from "@/directive/directives.js"
app.use(Directives)
```

附件上传函数的封装

```javascript
//#####··········附件上传··········#####//
export const upload = (files) => {
  return instance.request({
      //#####··········附件上传请求方式··········#####//
      method: 'POST',
      //#####··········附件上传地址··········#####//
      url: '/file/file/createFile',
      data: {},
      transformRequest: function (data, headersGetter) {
          var newFormData = new FormData();
          files.forEach(item => {
              newFormData.append('file', item)
          })
          return newFormData;
      },
  })
}
```

**vue3.0注册全局组件**

index.js

```javascript
import countDown from './countDown.vue'

const UILCOUNT = {
    install (Vue) {
        Vue.component("countDown", countDown)
    }
}

export default UILCOUNT
```

main.js

```javascript
import UILCOUNT from '@/views/countDown/index.js'
const app = createApp(App)
app.use(UILCOUNT)
```

**vue3.0自定义指令的三种使用方式**

1.vue3.0局部自定义指令

```html
<h3 v-drag>大屏可视化</h3>
```

```javascript
const vDrag = {
  mounted(el) {
    el.onmousedown = (ev) => {
      let v = '鼠标按下'
      console.log(v);
      console.log(ev.type);
      console.log(el);
    }
    el.onmouseup = (ev) => {
      let v = '鼠标抬起'
      console.log(v);
      console.log(ev.type);
    }
  },
}
```

2.vue3.0全局自定义指令

```html
<mytime class="my-time" v-foucs/>
```

```javascript
const app = createApp(App)
// vue3.0全局自定义指令
app.directive('foucs',{
    mounted(el) {
        el.onmouseenter = (ev) => {
            let v = '鼠标移入'
            console.log(v);
            console.log(ev.type);
            console.log(el);
        }
        el.onmouseleave = (ev) => {
            let v = '鼠标移出'
            console.log(v);
            console.log(ev.type);
        }
    }
})
```

3.vue3.0封装后的全局自定义指令

```html
<router-view v-deep></router-view>
```

directive.js

```javascript
const vDeep = {
    mounted(el) {
        el.onclick = (ev) => {
            let v = '鼠标点击'
            console.log(v);
            console.log(ev.type);
            console.log(el);
        }
    },
}

const directives = {
    install(app) {
        app.directive('deep', vDeep)
    }
}

export default directives
```

main.js

```javascript
import Directives from './directives/directive.js'
app.use(Directives)
```

```css
/* x轴偏移  y轴偏移  阴影模糊半径  阴影扩散半径  inset(阴影向内扩散)没写inset(阴影向外扩散)  阴影颜色 */
box-shadow: 0px 0px 5px 1px inset #1bb4f9;
/* x轴偏移  y轴偏移  阴影模糊半径  inset(阴影向内扩散)没写inset(阴影向外扩散)  阴影颜色 */
text-shadow: 0px 0px 5px inset #1bb4f9;
```

**Element.getBoundingClientRect()**

**`Element.getBoundingClientRect()`** 方法返回一个 [`DOMRect`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect) 对象，其提供了元素的大小及其相对于[视口](https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport)的位置

无参数

返回值是一个 [`DOMRect`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect) 对象，是包含整个元素的最小矩形（包括 `padding` 和 `border-width`）。该对象使用 `left`、`top`、`right`、`bottom`、`x`、`y`、`width` 和 `height` 这几个以像素为单位的只读属性描述整个矩形的位置和大小。除了 `width` 和 `height` 以外的属性是相对于视图窗口的左上角来计算的。

该方法返回的 [`DOMRect`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect) 对象中的 `width` 和 `height` 属性是包含了 `padding` 和 `border-width` 的，而不仅仅是内容部分的宽度和高度。在标准盒子模型中，这两个属性值分别与元素的 `width`/`height` + `padding` + `border-width` 相等。而如果是 [`box-sizing: border-box`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing)，两个属性则直接与元素的 `width` 或 `height` 相等。

这个对象是由该元素的 [`getClientRects()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects) 方法返回的一组矩形的集合，就是该元素的 CSS 边框大小。

空边框盒（译者注：没有内容的边框）会被忽略。如果所有的元素边框都是空边框，那么这个矩形给该元素返回的 `width`、`height` 值为 0，`left`、`top` 值为第一个 CSS 盒子（按内容顺序）的 top-left 值。

如果你需要获得边界矩形相对于整个网页左上角的位置，则可以将当前的滚动位置（可通过 [`window.scrollX`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollX) 和 [`window.scrollY`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollY) 获得）添加到 `top` 和 `left` 属性上。获得的边界矩形与当前的滚动位置无关

**CSS实现三维旋转效果**

html

```html
<div class="echarts">
     <div id="ex1" class="container">
          <div id="ex1-layer" class="box"></div>
     </div>
</div>
```

js

```javascript
import {
    ref,
    defineEmits,
    defineProps,
    nextTick,
    reactive,
    onMounted,
    watch,
    computed,
    onUnmounted,
    onBeforeUnmount,
} from "vue";
import { useStore } from "vuex";
import { useRouter, useRoute } from "vue-router";
const router = useRouter()
const route = useRoute()
const constrain = ref(20)
const transforms = (x, y, el) => {
    let box = el.getBoundingClientRect();
    console.log(box);
    let calcX = -(y - box.y - (box.height / 2)) / constrain.value
    let calcY = (x - box.x - (box.width / 2)) / constrain.value

    return "perspective(100px) "
        + "   rotateX(" + calcX + "deg) "
        + "   rotateY(" + calcY + "deg) ";
}
const transformElement = (el, xyEl) => {
    el.style.transform = transforms.apply(null, xyEl);
}
onMounted(() => {
    const mouseOverContainer = document.getElementById("ex1")
    const ex1Layer = document.getElementById("ex1-layer")
    mouseOverContainer.onmousemove = function (e) {
        let xy = [e.clientX, e.clientY];
        let position = xy.concat([ex1Layer]);

        window.requestAnimationFrame(() => {
            transformElement(ex1Layer, position);
        });
    };
})
```

css

```css
.echarts {
    width: 100%;
    height: 100%
}

.container {
    height: 100%;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.box {
    border: 2px solid red;
    height: 100px;
    width: 100px;
    position: absolute;
}
```

**CSS流光效果**

html

```html
<div class="container">
   <span class="line-top"></span>
   <span class="line-right"></span>
   <span class="line-bottom"></span>
   <span class="line-left"></span>
   <span class="css">css流光效果</span>
</div>
```

css

```css
.container {
    width: 400px;
    height: 400px;
    position: relative;
    border: 1px solid #0e96e7;
    display: flex;
    align-items: center;
    background: linear-gradient(to bottom,black, #0e96e7, black);
    justify-content: center;
}

.css {
    color: white;
}

.line-top {
    position: absolute;
    width: 80px;
    height: 1px;
    top: -1px;
    left: 0;
    background: linear-gradient(to right, #0e96e7, #fff);
    border-radius: 50%;
    animation: left_to_right 4s 0s linear infinite;
}

.line-top::before {
    content: "";
    position: absolute;
    width: 100%;
    height: 11px;
    background: linear-gradient(to right, transparent, #0e96e7, #fff);
    left: 0;
    top: -5px;
    filter: blur(4px);
    z-index: -1;
}

.line-right {
    position: absolute;
    width: 1px;
    height: 0;
    top: 0;
    right: -1px;
    background: linear-gradient(#0e96e7, #fff);
    animation: top_to_bottom 4s 3s linear infinite;
}

.line-right::before {
    content: "";
    position: absolute;
    width: 11px;
    height: 100%;
    background: linear-gradient(to bottom, transparent, #0e96e7, #fff);
    left: -5px;
    top: 0;
    filter: blur(4px);
    z-index: -1;
}

.line-bottom {
    position: absolute;
    width: 0;
    height: 1px;
    bottom: -1px;
    right: 0;
    background: linear-gradient(to left, #0e96e7, #fff);
    border-radius: 50%;
    animation: right_to_left 4s 6s linear infinite;
}

.line-bottom::before {
    content: "";
    position: absolute;
    width: 100%;
    height: 11px;
    background: linear-gradient(to left, transparent, #0e96e7, #fff);
    left: 0;
    top: -5px;
    filter: blur(4px);
    z-index: -1;
}

.line-left {
    position: absolute;
    width: 1px;
    height: 0;
    bottom: 0;
    left: -1px;
    background: linear-gradient(to top, #0e96e7, #fff);
    animation: bottom_to_top 4s 9s linear infinite;
}

.line-left::before {
    content: "";
    position: absolute;
    width: 11px;
    height: 100%;
    background: linear-gradient(to top, transparent, #0e96e7, #fff);
    left: -5px;
    top: 0;
    filter: blur(4px);
    z-index: -1;
}


@keyframes left_to_right {
    0% {
        width: 0;
        left: 0;
    }

    25% {
        left: 0;
        width: 80px;
    }

    75% {
        left: calc(100% - 80px);
        width: 80px;
    }

    100% {
        left: 100%;
        width: 0;
    }
}

@keyframes top_to_bottom {
    0% {
        top: 0;
        height: 0;
    }

    25% {
        top: 0;
        height: 80px;
    }

    75% {
        top: calc(100% - 80px);
        height: 80px;
    }

    100% {
        top: 100%;
        height: 0;
    }
}

@keyframes right_to_left {
    0% {
        right: 0;
    }

    25% {
        width: 80px;
        right: 0;
    }

    75% {
        width: 80px;
        right: calc(100% - 80px);
    }

    100% {
        right: 100%;
        width: 0;
    }
}

@keyframes bottom_to_top {
    0% {
        bottom: 0;
    }

    25% {
        bottom: 0;
        height: 80px;
    }

    75% {
        height: 80px;
        bottom: calc(100% - 80px);
    }


    100% {
        height: 0;
    }
```

**虚拟列表插件使用**

**地址：[vxe-table v4 (vxetable.cn)](https://vxetable.cn/v4/#/table/scroll/scroll)**

npm install xe-utils vxe-table@next

main.js

```javascript
import VXETable from "vxe-table";
import "vxe-table/lib/style.css";
function useTable(app) {
    app.use(VXETable);
}
app.use(useTable)
```

VirtualList.vue

html

```html
<template>
    <vxe-table border show-overflow highlight-hover-row ref="xTable1" height="600">
        <vxe-column type="seq" width="100"></vxe-column>
        <vxe-column field="name" title="Names" sortable></vxe-column>
        <vxe-column field="role" title="Roles"></vxe-column>
        <vxe-column field="sex" title="Sexs"></vxe-column>
    </vxe-table>
</template>
```

js

```javascript
<script setup>
import { ref, onMounted, nextTick } from "vue";
import XEUtils from "xe-utils";

const mockList1 = ref([])
for (let i = 0; i < 1000; i++) {
    mockList1.value.push({
        name: "Test" + i,
        role: "Developer",
        sex: "男",
    });
}

const xTable1 = ref(null);

onMounted(() => {
    nextTick(() => {
        const table = xTable1.value;
        console.log(table);
        if (table) {
            table.loadData(XEUtils.clone(mockList1.value, true));
        }
    });
});
</script>
```

封装成组件

```javascript
import VirtualList from './VirtualList.vue'

const virtualList = {
    install (app) {
        app.component('VirtualList',VirtualList)
    }
}

export default virtualList
```

**node-sass问题项目安装不了依赖**

**安装淘宝镜像**

```javascript
npm install -g mirror-config-china --registry=https://registry.npmmirror.com
```

**安装node-sass**

```javascript
npm install node-sass@6.0.1 --save-dev
```

**安装sass-loader**

```javascript
npm install sass-loader@10.2.0 --save-dev
```

